<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OpenMLS Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-230066a7.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-e31a8293.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">OpenMLS Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<!-- Get the Readme without the headline until (including) the introductory sentence  -->
<p><a href="https://openmls.zulipchat.com"><img src="https://img.shields.io/badge/zulip-join_chat-blue.svg?style=for-the-badge&amp;logo=zulip" alt="OpenMLS Chat"></a>
<a href="https://groups.google.com/u/0/g/openmls-dev"><img src="https://img.shields.io/badge/mailing-list-blue.svg?style=for-the-badge" alt="OpenMLS List"></a></p>
<p><a href="https://github.com/openmls/openmls/actions/workflows/tests.yml?branch=main"><img src="https://img.shields.io/github/actions/workflow/status/openmls/openmls/tests.yml?branch=main&amp;style=for-the-badge&amp;logo=github" alt="Tests &amp; Checks"></a>
<a href="https://codecov.io/gh/openmls/openmls"><img src="https://img.shields.io/codecov/c/github/openmls/openmls/main?logo=codecov&amp;style=for-the-badge" alt="codecov"></a></p>
<p><a href="https://docs.rs/crate/openmls/latest"><img src="https://img.shields.io/badge/docs-release-blue.svg?style=for-the-badge" alt="Docs"></a>
<a href="https://book.openmls.tech"><img src="https://img.shields.io/badge/book-release-blue.svg?style=for-the-badge" alt="Book"></a>
<img src="https://img.shields.io/badge/rustc-1.56+-blue.svg?style=for-the-badge&amp;logo=rust" alt="Rust Version"></p>
<p><em>OpenMLS</em> is a Rust implementation of the Messaging Layer Security (MLS) protocol, as specified in <a href="https://datatracker.ietf.org/doc/html/rfc9420">RFC 9420</a>.
OpenMLS provides a high-level API to create and manage MLS groups. It supports basic ciphersuites and an interchangeable cryptographic provider, key store, and random number generator.</p>
<p>This book provides guidance on using OpenMLS and its <code>MlsGroup</code> API to perform basic group operations, illustrated with examples.</p>
<!-- Get the rest of the Readme -->
<h2 id="supported-ciphersuites"><a class="header" href="#supported-ciphersuites">Supported ciphersuites</a></h2>
<ul>
<li>MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519 (MTI)</li>
<li>MLS_128_DHKEMP256_AES128GCM_SHA256_P256</li>
<li>MLS_128_DHKEMX25519_CHACHA20POLY1305_SHA256_Ed25519</li>
</ul>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported platforms</a></h2>
<p>OpenMLS is built and tested on the Github CI for the following rust targets.</p>
<ul>
<li>x86_64-unknown-linux-gnu</li>
<li>i686-unknown-linux-gnu</li>
<li>x86_64-pc-windows-msvc</li>
<li>i686-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
</ul>
<h3 id="unsupported-but-built-on-ci"><a class="header" href="#unsupported-but-built-on-ci">Unsupported, but built on CI</a></h3>
<p>The Github CI also builds (but doesn’t test) the following rust targets.</p>
<ul>
<li>aarch64-apple-darwin</li>
<li>aarch64-unknown-linux-gnu</li>
<li>aarch64-linux-android</li>
<li>aarch64-apple-ios</li>
<li>aarch64-apple-ios-sim</li>
<li>wasm32-unknown-unknown</li>
<li>armv7-linux-androideabi</li>
<li>x86_64-linux-android</li>
<li>i686-linux-android</li>
</ul>
<p>OpenMLS supports 32 bit platforms and above.</p>
<h2 id="cryptography-dependencies"><a class="header" href="#cryptography-dependencies">Cryptography Dependencies</a></h2>
<p>OpenMLS does not implement its own cryptographic primitives. Instead, it relies
on existing implementations of the cryptographic primitives used by MLS. There
are two different cryptography providers implemented right now. But consumers
can bring their own implementation. See <a href="https://github.com/openmls/openmls/tree/main/traits">traits</a> for more
details.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>OpenMLS provides the following features</p>
<ul>
<li><strong>extensions-draft-08</strong>: enable features defined in <a href="https://messaginglayersecurity.rocks/mls-extensions/draft-ietf-mls-extensions.html">MLS extensions draft-08</a></li>
<li><strong>fork-resolution</strong>: helper functionality for <a href="https://book.openmls.tech/user_manual/fork-resolution.html">resolving forks</a>.</li>
<li><strong>js</strong>: enable compilation to wasm</li>
</ul>
<details>
<summary>Developer features</summary>
<ul>
<li><strong>libcrux-provider</strong>: enable the libcrux crypto provider dependency</li>
<li><strong>openmls_rust_crypto</strong>: enable the rust crypto provider</li>
<li><strong>sqlite-provider</strong>: enable the sqlite provider</li>
<li><strong>backtrace</strong>: enable backtraces</li>
<li><strong>content-debug</strong>: allow printing sensitive content of messages for debugging</li>
<li><strong>crypto-debug</strong>: allow printing cryptographic key material for debugging</li>
<li><strong>test-util</strong>: test utilities</li>
</ul>
</details>
<h2 id="working-on-openmls"><a class="header" href="#working-on-openmls">Working on OpenMLS</a></h2>
<p>For more details when working on OpenMLS itself please see the <a href="https://github.com/openmls/openmls/blob/main/Developer.md">Developer.md</a>.</p>
<h2 id="maintenance--support"><a class="header" href="#maintenance--support">Maintenance &amp; Support</a></h2>
<p>OpenMLS is maintained and developed by <a href="https://phnx.im">Phoenix R&amp;D</a> and <a href="https://cryspen.com">Cryspen</a>.</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p><a href="https://zulip.com/">Zulip</a> graciously provides the OpenMLS community with a “Zulip Cloud Standard” tier <a href="https://openmls.zulipchat.com">Zulip instance</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="user-manual"><a class="header" href="#user-manual">User manual</a></h1>
<p>The user manual describes how to use the different parts of the OpenMLS API.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Most operations in OpenMLS require a <code>provider</code> object that provides all required cryptographic algorithms via the [<code>OpenMlsProvider</code>] trait.
Currently, there are two implementations available:</p>
<ul>
<li>one through the <a href="https://crates.io/crates/openmls_rust_crypto">openmls_rust_crypto</a> crate.</li>
<li>one through the <a href="https://crates.io/crates/openmls_libcrux_crypto">openmls_libcrux_crypto</a> crate.</li>
</ul>
<p>Thus, you can create the <code>provider</code> object for the following examples using …</p>
<pre><code class="language-rust no_run noplayground">    let provider: OpenMlsRustCrypto = OpenMlsRustCrypto::default();</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="credentials"><a class="header" href="#credentials">Credentials</a></h1>
<p>MLS relies on credentials to encode the identity of clients in the context of a group.
There are different types of credentials, with the OpenMLS library currently only supporting the <code>BasicCredential</code> credential type (see below).
Credentials are used to authenticate messages by the owner in the context of a group.
Note that the link between the credential and its signature keys depends on the credential type.
For example, the link between the <code>BasicCredential</code>’s and its keys is not defined by MLS.</p>
<p>A credential is always embedded in a leaf node, which is ultimately used to represent a client in a group and signed by the private key corresponding to the signature public key of the leaf node.
Clients can decide to use the same credential in multiple leaf nodes (and thus multiple groups) or to use distinct credentials per group.</p>
<p>The binding between a given credential and owning client’s identity is, in turn, authenticated by the Authentication Service, an abstract authentication layer defined by the <a href="https://www.rfc-editor.org/rfc/rfc9750.html">MLS architecture document</a>.
Note that the implementation of the Authentication Service and, thus, the details of how the binding is authenticated are not specified by MLS.</p>
<h2 id="creating-and-using-credentials"><a class="header" href="#creating-and-using-credentials">Creating and using credentials</a></h2>
<p>OpenMLS allows clients to create <code>Credentials</code>.
A <code>BasicCredential</code>, currently the only credential type supported by OpenMLS, consists only of the <code>identity</code>.
Thus, to create a fresh <code>Credential</code>, the following inputs are required:</p>
<ul>
<li><code>identity: Vec&lt;u8&gt;</code>: An octet string that uniquely identifies the client.</li>
<li><code>credential_type: CredentialType</code>: The type of the credential, in this case <code>CredentialType::Basic</code>.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    let credential = BasicCredential::new(identity);</code></pre>
<p>After creating the credential bundle, clients should create keys for it.
OpenMLS provides a <a href="https://github.com/openmls/openmls/tree/main/basic_credential">simple implementation of <code>BasicCredential</code></a> for tests and to demonstrate how to use credentials.</p>
<pre><code class="language-rust no_run noplayground">    let signature_keys = SignatureKeyPair::new(signature_algorithm).unwrap();
    signature_keys.store(provider.storage()).unwrap();</code></pre>
<p>All functions and structs related to credentials can be found in the <a href="https://docs.rs/openmls/latest/openmls/credentials/index.html"><code>credentials</code></a> module.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="key-packages"><a class="header" href="#key-packages">Key packages</a></h1>
<p>To enable the asynchronous establishment of groups through pre-publishing key material, as well as to represent clients in the group, MLS relies on key packages. Key packages hold several pieces of information:</p>
<ul>
<li>a public HPKE encryption key to enable MLS’ basic group key distribution feature</li>
<li>the lifetime throughout which the key package is valid</li>
<li>information about the client’s capabilities (i.e., which features of MLS it supports)</li>
<li>any extension that the client wants to include</li>
<li>one of the client’s <a href="#credentials">credentials</a>, as well as a signature over the whole key package using the private key corresponding to the credential’s signature public key</li>
</ul>
<h2 id="creating-key-packages"><a class="header" href="#creating-key-packages">Creating key packages</a></h2>
<p>Before clients can communicate with each other using OpenMLS, they need to generate key packages and publish them with the Delivery Service. Clients can generate an arbitrary number of key packages ahead of time.</p>
<p>Clients keep the private key material corresponding to a key package locally in the key store and fetch it from there when a key package was used to add them to a new group.</p>
<p>Clients need to choose a few parameters to create a <code>KeyPackageBundle</code>:</p>
<ul>
<li><code>ciphersuites: &amp;[CiphersuiteName]</code>: A list of ciphersuites supported by the client.</li>
<li><code>extensions: Vec&lt;Extensions&gt;</code>: A list of supported extensions.</li>
</ul>
<p>Clients must specify at least one ciphersuite and not advertise ciphersuites they do not support.</p>
<p>Clients should specify all extensions they support. See the documentation of extensions for more details.</p>
<pre><code class="language-rust no_run noplayground">    // Create the key package
    KeyPackage::builder()
        .key_package_extensions(extensions)
        .build(ciphersuite, provider, signer, credential_with_key)
        .unwrap()</code></pre>
<p>This will also store the private key for the key package in the key store.</p>
<p>All functions and structs related to key packages can be found in the <a href="https://docs.rs/openmls/latest/openmls/key_packages/index.html"><code>key_packages</code></a> module.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="group-configuration"><a class="header" href="#group-configuration">Group configuration</a></h1>
<p>Two very similar structs can help configure groups upon their creation: <code>MlsGroupJoinConfig</code> and <code>MlsGroupCreateConfig</code>.</p>
<p><code>MlsGroupJoinConfig</code> contains the following runtime-relevant configuration options for an <code>MlsGroup</code> and can be set on a per-client basis when a group is joined.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Explanation</th></tr>
</thead>
<tbody>
<tr><td><code>wire_format_policy</code></td><td><code>WireFormatPolicy</code></td><td>Defines the wire format policy for outgoing and incoming handshake messages.</td></tr>
<tr><td><code>padding_size</code></td><td><code>usize</code></td><td>Size of padding in bytes. The default is 0.</td></tr>
<tr><td><code>max_past_epochs</code></td><td><code>usize</code></td><td>Maximum number of past epochs for which application messages can be decrypted. The default is 0.</td></tr>
<tr><td><code>number_of_resumption_psks</code></td><td><code>usize</code></td><td>Number of resumption psks to keep. The default is 0.</td></tr>
<tr><td><code>use_ratchet_tree_extension</code></td><td><code>bool</code></td><td>Flag indicating the Ratchet Tree Extension should be used. The default is <code>false</code>.</td></tr>
<tr><td><code>sender_ratchet_configuration</code></td><td><code>SenderRatchetConfiguration</code></td><td>Sender ratchet configuration.</td></tr>
</tbody>
</table>
</div>
<p><code>MlsGroupCreateConfig</code> contains an <code>MlsGroupJoinConfig</code>, as well as a few additional parameters that are part of the group state that is agreed-upon by all group members. It can be set at the time of a group’s creation and contains the following additional configuration options.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Explanation</th></tr>
</thead>
<tbody>
<tr><td><code>group_context_extensions</code></td><td><code>Extensions</code></td><td>Optional group-level extensions, e.g. <code>RequiredCapabilitiesExtension</code>.</td></tr>
<tr><td><code>capabilities</code> .</td><td><code>Capabilities</code></td><td>Lists the capabilities of the group’s creator.</td></tr>
<tr><td><code>leaf_extensions</code> .</td><td><code>Extensions</code></td><td>Extensions to be included in the group creator’s leaf</td></tr>
</tbody>
</table>
</div>
<p>Both ways of group configurations can be specified by using the struct’s builder pattern, or choosing their default values. The default value contains safe values for all parameters and is suitable for scenarios without particular requirements.</p>
<p>Example join configuration:</p>
<pre><code class="language-rust no_run noplayground">    let mls_group_config = MlsGroupJoinConfig::builder()
        .padding_size(100)
        .sender_ratchet_configuration(SenderRatchetConfiguration::new(
            10,   // out_of_order_tolerance
            2000, // maximum_forward_distance
        ))
        .use_ratchet_tree_extension(true)
        .build();</code></pre>
<p>Example create configuration:</p>
<pre><code class="language-rust no_run noplayground">    let mls_group_create_config = MlsGroupCreateConfig::builder()
        .padding_size(100)
        .sender_ratchet_configuration(SenderRatchetConfiguration::new(
            10,   // out_of_order_tolerance
            2000, // maximum_forward_distance
        ))
        .with_group_context_extensions(
            Extensions::single(Extension::ExternalSenders(vec![ExternalSender::new(
                ds_credential_with_key.signature_key.clone(),
                ds_credential_with_key.credential.clone(),
            )]))
            .expect("failed to create single-element extensions list"),
        )
        .ciphersuite(ciphersuite)
        // we need to specify the non-default extension here
        .capabilities(Capabilities::new(
            None, // Defaults to the group's protocol version
            None, // Defaults to the group's ciphersuite
            Some(&amp;[ExtensionType::Unknown(0xff00)]),
            None, // Defaults to all basic extension types
            Some(&amp;[CredentialType::Basic]),
        ))
        // Example leaf extension
        .with_leaf_node_extensions(
            Extensions::single(Extension::Unknown(
                0xff00,
                UnknownExtension(vec![0, 1, 2, 3]),
            ))
            .expect("failed to create single-element extensions list"),
        )
        .expect("failed to configure leaf extensions")
        .use_ratchet_tree_extension(true)
        .build();</code></pre>
<h2 id="unknown-extensions"><a class="header" href="#unknown-extensions">Unknown extensions</a></h2>
<p>Some extensions carry data, but don’t alter the behaviour of the protocol (e.g. the application_id extension). OpenMLS allows the use of arbitrary such extensions in the group context, key packages and leaf nodes. Such extensions can be instantiated and retrieved through the use of the <code>UnknownExtension</code> struct and the <code>ExtensionType::Unknown</code> extension type. Such “unknown” extensions are handled transparently by OpenMLS, but can be used by the application, e.g. to have a group agree on pieces of data.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-groups"><a class="header" href="#creating-groups">Creating groups</a></h1>
<p>There are two ways to create a group: Either by building an <code>MlsGroup</code> directly, or by using an <code>MlsGroupCreateConfig</code>. The former is slightly simpler, while the latter allows the creating of multiple groups using the same configuration. See <a href="#group-configuration">Group configuration</a> for more details on group parameters.</p>
<p>In addition to the group configuration, the client should define all supported and required extensions for the group. The negotiation mechanism for extension in MLS consists in setting an initial list of extensions at group creation time and choosing key packages of subsequent new members accordingly.</p>
<p>In practice, the supported and required extensions are set by adding them to the initial <code>KeyPackage</code> of the creator:</p>
<pre><code class="language-rust no_run noplayground">    // Create the key package
    KeyPackage::builder()
        .key_package_extensions(extensions)
        .build(ciphersuite, provider, signer, credential_with_key)
        .unwrap()</code></pre>
<p>After that, the group can be created either using a config:</p>
<pre><code class="language-rust no_run noplayground">    let mut alice_group = MlsGroup::new(
        alice_provider,
        &amp;alice_signature_keys,
        &amp;mls_group_create_config,
        alice_credential.clone(),
    )
    .expect("An unexpected error occurred.");</code></pre>
<p>… or using the builder pattern:</p>
<pre><code class="language-rust no_run noplayground">        let mut alice_group = MlsGroup::builder()
            .padding_size(100)
            .sender_ratchet_configuration(SenderRatchetConfiguration::new(
                10,   // out_of_order_tolerance
                2000, // maximum_forward_distance
            ))
            .ciphersuite(ciphersuite)
            .use_ratchet_tree_extension(true)
            .build(
                alice_provider,
                &amp;alice_signature_keys,
                alice_credential.clone(),
            )
            .expect("An unexpected error occurred.");</code></pre>
<p>Note: Every group is assigned a random group ID during creation. The group ID cannot be changed and remains immutable throughout the group’s lifetime. Choosing it randomly makes sure that the group ID doesn’t collide with any other group ID in the same system.</p>
<p>If someone else already gave you a group ID, e.g., a provider server, you can also create a group using a specific group ID:</p>
<pre><code class="language-rust no_run noplayground">        // Some specific group ID generated by someone else.
        let group_id = GroupId::from_slice(b"123e4567e89b");

        let mut alice_group = MlsGroup::new_with_group_id(
            alice_provider,
            &amp;alice_signature_keys,
            &amp;mls_group_create_config,
            group_id,
            alice_credential.clone(),
        )
        .expect("An unexpected error occurred.");</code></pre>
<p>The Builder provides methods for setting required capabilities and external senders.
The information passed into these lands in the group context, in the form of extensions.
Should the user want to add further extensions, they can use the <code>with_group_context_extensions</code> method:</p>
<pre><code class="language-rust no_run noplayground">        // we are adding an external senders list as an example.
        let extensions =
            Extensions::from_vec(vec![Extension::ExternalSenders(external_senders_list)])
                .expect("failed to create extensions list");

        let mut alice_group = MlsGroup::builder()
            .padding_size(100)
            .sender_ratchet_configuration(SenderRatchetConfiguration::new(
                10,   // out_of_order_tolerance
                2000, // maximum_forward_distance
            ))
            .with_group_context_extensions(extensions) // NB: the builder method returns a Result
            .use_ratchet_tree_extension(true)
            .build(
                alice_provider,
                &amp;alice_signature_keys,
                alice_credential.clone(),
            )
            .expect("An unexpected error occurred.");</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="join-a-group-from-a-welcome-message"><a class="header" href="#join-a-group-from-a-welcome-message">Join a group from a Welcome message</a></h1>
<p>To join a group from a <code>Welcome</code> message, a new <code>MlsGroup</code> can be instantiated from
the <code>MlsMessageIn</code> message containing the <code>Welcome</code> and an <code>MlsGroupJoinConfig</code>
(see <a href="#group-configuration">Group configuration</a> for more details). This is a
two-step process: a <code>StagedWelcome</code> is constructed from the <code>Welcome</code>
and can then be turned into an <code>MlsGroup</code>. If the group configuration does not
use the ratchet tree extension, the ratchet tree needs to be provided.</p>
<pre><code class="language-rust no_run noplayground">    let staged_join =
        StagedWelcome::new_from_welcome(bob_provider, &amp;mls_group_config, welcome, None)
            .expect("Error constructing staged join");
    let mut bob_group = staged_join
        .into_group(bob_provider)
        .expect("Error joining group from StagedWelcome");</code></pre>
<p>The reason for this two-phase process is to allow the recipient of a <code>Welcome</code>
to inspect the message, e.g. to determine the identity of the sender.</p>
<p>Pay attention not to forward a Welcome message to a client before its associated
commit has been accepted by the Delivery Service. Otherwise, you would end up
with an invalid MLS group instance.</p>
<h1 id="examining-a-welcome-message"><a class="header" href="#examining-a-welcome-message">Examining a welcome message</a></h1>
<p>When a client is invited to join a group, the application can allow the client to decide whether or not to join the group. In order to determine whether to join the group, the application can inspect information provided in the welcome message, such as who invited them, who else is in the group, what extensions are available, and more. If the application decides not to join the group, the welcome must be discarded to ensure that the local state is cleaned up.</p>
<p>After receiving a <code>MlsMessageIn</code> from the delivery service, the first step is to extract the <code>MlsMessageBodyIn</code>, and determine whether it is a welcome message.</p>
<pre><code class="language-rust no_run noplayground">    let welcome = match welcome.extract() {
        MlsMessageBodyIn::Welcome(welcome) =&gt; welcome,
        _ =&gt; unimplemented!("Handle other message types"),
    };</code></pre>
<p>The next step is to process the <code>Welcome</code>. This removes the consumed <code>KeyPackage</code> from the <code>StorageProvider</code>, unless it is a last resort <code>KeyPackage</code>.</p>
<pre><code class="language-rust no_run noplayground">    let join_config = MlsGroupJoinConfig::default();
    // This deletes the keys used to decrypt the welcome, except if it is a last resort key
    // package.
    let processed_welcome = ProcessedWelcome::new_from_welcome(bob_provider, &amp;join_config, welcome)
        .expect("Error constructing processed welcome");</code></pre>
<p>At this stage, there are some more pieces of information in the <code>ProcessedWelcome</code> that could be useful to the application. For example, it can be useful to check which extensions are available. However, the pieces of information that are retrieved from the <code>ProcessedWelcome</code> are unverified, and verified values are only available from the <code>StagedWelcome</code> that is produced in the next step.</p>
<pre><code class="language-rust no_run noplayground">    // unverified pre-shared keys (`&amp;[PreSharedKeyId]`)
    let _unverified_psks = processed_welcome.psks();

    // unverified group info (`VerifiableGroupInfo`)
    let unverified_group_info = processed_welcome.unverified_group_info();

    // From the unverified group info, the ciphersuite, group_id, and other information
    // can be retrieved.
    let _ciphersuite = unverified_group_info.ciphersuite();
    let _group_id = unverified_group_info.group_id();
    let _epoch = unverified_group_info.epoch();

    // Can also retrieve any available extensions
    let extensions = unverified_group_info.extensions();

    // Retrieving the ratchet tree extension
    let ratchet_tree_extension = extensions
        .ratchet_tree()
        .expect("No ratchet tree extension");
    // The (unverified) ratchet tree itself can also be inspected
    let _ratchet_tree = ratchet_tree_extension.ratchet_tree();</code></pre>
<p>The next step is to stage the <code>ProcessedWelcome</code>.</p>
<pre><code class="language-rust no_run noplayground">    let staged_welcome: StagedWelcome = processed_welcome
        .into_staged_welcome(bob_provider, None)
        .expect("Error constructing staged welcome");</code></pre>
<p>Then, more information about the welcome message’s sender, such as the credential, signature public key, and encryption public key can also be individually inspected. The welcome message sender’s credential can be validated at this stage.</p>
<pre><code class="language-rust no_run noplayground">    let welcome_sender: &amp;LeafNode = staged_welcome
        .welcome_sender()
        .expect("Welcome sender could not be retrieved");

    // Inspect sender's credential...
    let _credential = welcome_sender.credential();
    // Inspect sender's signature public key...
    let _signature_key = welcome_sender.signature_key();</code></pre>
<p>Additionally, some information about the other group members is made available, e.g. credentials and signature public keys for credential validation.</p>
<pre><code class="language-rust no_run noplayground">    // Inspect the group members
    for member in staged_welcome.members() {
        // leaf node index
        let _leaf_node_index = member.index;
        // credential
        let _credential = member.credential;
        // encryption public key
        let _encryption_key = member.encryption_key;
        // signature public key
        let _signature_key = member.signature_key;
    }</code></pre>
<p>Lastly, the <code>GroupContext</code> contains several other useful pieces of information, including the protocol version, the extensions enabled on the group, and the required extension, proposal, and credential types.</p>
<pre><code class="language-rust no_run noplayground">    // Inspect group context...
    let group_context = staged_welcome.group_context();

    // inspect protocol version...
    let _protocol_version = group_context.protocol_version();
    // Inspect ciphersuite...
    let _ciphersuite = group_context.ciphersuite();
    // Inspect extensions...
    let extensions: &amp;Extensions&lt;GroupContext&gt; = group_context.extensions();

    // Can check which extensions are enabled
    let _has_ratchet_extension = extensions.ratchet_tree().is_some();

    // Inspect required capabilities...
    if let Some(capabilities) = group_context.required_capabilities() {
        // Inspect required extension types...
        let _extension_types: &amp;[ExtensionType] = capabilities.extension_types();
        // Inspect required proposal types...
        let _proposal_types: &amp;[ProposalType] = capabilities.proposal_types();
        // Inspect required credential types...
        let _credential_types: &amp;[CredentialType] = capabilities.credential_types();
    }
    // Additional information from the `GroupContext`
    let _group_id = group_context.group_id();
    let _epoch = group_context.epoch();
    let _tree_hash = group_context.tree_hash();
    let _confirmed_transcript_hash = group_context.confirmed_transcript_hash();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="join-a-group-with-an-external-commit"><a class="header" href="#join-a-group-with-an-external-commit">Join a group with an external commit</a></h1>
<p>To join a group with an external commit message, a new <code>MlsGroup</code> can be instantiated directly from the <code>GroupInfo</code>.
The <code>GroupInfo</code>/Ratchet Tree should be shared over a secure channel.
If the RatchetTree extension is not included in the <code>GroupInfo</code> as a <code>GroupInfoExtension</code>, then the ratchet tree needs to be provided.</p>
<p>The <code>GroupInfo</code> can be obtained either from a call to <code>export_group_info</code>from the <code>MlsGroup</code>:</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome, group_info) = alice_group
        .add_members(
            alice_provider,
            &amp;alice_signature_keys,
            core::slice::from_ref(bob_key_package.key_package()),
        )
        .expect("Could not add members.");</code></pre>
<p>Or from a call to a function that results in a staged commit:</p>
<pre><code class="language-rust no_run noplayground">    let verifiable_group_info = alice_group
        .export_group_info(alice_provider.crypto(), &amp;alice_signature_keys, true)
        .expect("Cannot export group info")
        .into_verifiable_group_info()
        .expect("Could not get group info");</code></pre>
<p>External commits can be created using a builder pattern via <code>MlsGroup::external_commit_builder()</code>. The <code>ExternalCommitBuilder</code> provides more options than <code>join_by_external</code> in that it allows the inclusion of SelfRemove or PSK proposals. After its first stage, the <code>ExternalCommitBuilder</code> turns into a regular <code>CommitBuilder</code>. As external commits come with a few restrictions relative to regular commits, not all <code>CommitBuilder</code> capabilities are exposed for external commits. Also, instead of <code>stage_commit</code> this <code>CommitBuilder</code> requires a call to <code>finalize</code> before it returns the new <code>MlsGroup</code>, as well as a <code>CommitMessageBundle</code> containing the external commit, as well as a potential <code>GroupInfo</code>.</p>
<pre><code class="language-rust no_run noplayground">    let (mut bob_group, commit_message_bundle) = MlsGroup::external_commit_builder()
        .with_ratchet_tree(tree_option.into())
        .with_config(join_group_config.clone())
        .with_aad(AAD.to_vec())
        .build_group(
            bob_provider,
            verifiable_group_info,
            bob_credential_with_key.clone(),
        )
        .expect("error building group")
        .leaf_node_parameters(leaf_node_parameters)
        .load_psks(bob_provider.storage())
        .expect("error loading psks")
        .build(
            bob_provider.rand(),
            bob_provider.crypto(),
            &amp;bob_signer,
            |_| true,
        )
        .expect("error building external commit")
        .finalize(bob_provider)
        .expect("error finalizing external commit");</code></pre>
<p>The resulting external commit message needs to be fanned out to the Delivery Service and accepted by the other members before merging this external commit.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adding-members-to-a-group"><a class="header" href="#adding-members-to-a-group">Adding members to a group</a></h1>
<h2 id="immediate-operation"><a class="header" href="#immediate-operation">Immediate operation</a></h2>
<p>Members can be added to the group atomically with the <code>.add_members()</code> function. The application needs to fetch the corresponding key packages from every new member from the Delivery Service first.</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome, group_info) = alice_group
        .add_members(
            alice_provider,
            &amp;alice_signature_keys,
            core::slice::from_ref(bob_key_package.key_package()),
        )
        .expect("Could not add members.");</code></pre>
<p>The function returns the tuple <code>(MlsMessageOut, Welcome, Option&lt;GroupInfo&gt;)</code>. The <code>MlsMessageOut</code> contains a Commit message that needs to be fanned out to existing group members. The <code>Welcome</code> message must be sent to the newly added members, along the optional <code>GroupInfo</code> if it is available.</p>
<p>Users could also use the new <code>CommitBuilder</code> API, which would look like this:</p>
<pre><code class="language-rust no_run noplayground">    let message_bundle = alice_group
        .commit_builder()
        .propose_adds(Some(bob_key_package.key_package().clone()))
        .load_psks(alice_provider.storage())
        .expect("error loading psks")
        .build(
            alice_provider.rand(),
            alice_provider.crypto(),
            &amp;alice_signature_keys,
            |_proposal| true,
        )
        .expect("error validating data and building commit")
        .stage_commit(alice_provider)
        .expect("error staging commit");

    let (mls_message_out, welcome, group_info) = message_bundle.into_contents();</code></pre>
<p>Some notes on the arguments to the builder stages:</p>
<ul>
<li>The reason that the <code>KeyPackage</code> is wrapped in a <code>Some</code> is that <code>Option&lt;KeyPackage&gt;</code> implements <code>IntoIterator&lt;Item = KeyPackage&gt;</code>, which is the type bounds of that function. This means that the function also works with any iterator over <code>KeyPackage</code> items or a <code>Vec&lt;KeyPackage&gt;</code>.</li>
<li>The closure is a predicate over <code>&amp;QueuedProposal</code> and represents the policy of which proposals are deemed acceptable in the application.</li>
</ul>
<p>This function returns a <code>CommitMessageBundle</code>, from which the <code>MlsMessageOut</code>, <code>Welcome</code> and <code>GroupInfo</code> can be extracted.</p>
<h3 id="adding-members-without-update"><a class="header" href="#adding-members-without-update">Adding members without update</a></h3>
<p>The <code>.add_members_without_update()</code> function functions the same as the <code>.add_members()</code> function, except that it will only include an update to the sender’s key material if the sender’s proposal store includes a proposal that requires a path. For a list of proposals and an indication whether they require a <code>path</code> (i.e. a key material update) see <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-17.4">Section 17.4 of RFC 9420</a>.</p>
<p>Not sending an update means that the sender will not achieve post-compromise security with this particular commit. However, not sending an update saves on performance both in terms of computation and bandwidth. Using <code>.add_members_without_update()</code> can thus be a useful option if the ciphersuite of the group features large public keys and/or expensive encryption operations.</p>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>Members can also be added as a proposal (without the corresponding Commit message) by using the <code>.propose_add_member()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, _proposal_ref) = alice_group
        .propose_add_member(
            alice_provider,
            &amp;alice_signature_keys,
            bob_key_package.key_package(),
        )
        .expect("Could not create proposal to add Bob");</code></pre>
<p>In this case, the function returns an <code>MlsMessageOut</code> that needs to be fanned out to existing group members.</p>
<h2 id="external-proposal"><a class="header" href="#external-proposal">External proposal</a></h2>
<p>Parties outside the group can also make proposals to add themselves to the group with an external proposal. Since those
proposals are crafted by outsiders, they are always plaintext messages.</p>
<pre><code class="language-rust no_run noplayground">    let proposal =
        JoinProposal::new::&lt;&lt;Provider as openmls_traits::OpenMlsProvider&gt;::StorageProvider&gt;(
            bob_key_package.key_package().clone(),
            alice_group.group_id().clone(),
            alice_group.epoch(),
            &amp;bob_signature_keys,
        )
        .expect("Could not create external Add proposal");</code></pre>
<p>It is then up to the group members to validate the proposal and commit it.
Note that in this scenario it is up to the application to define a proper authorization policy to grant the sender.</p>
<pre><code class="language-rust no_run noplayground">    let alice_processed_message = alice_group
        .process_message(
            alice_provider,
            proposal
                .into_protocol_message()
                .expect("Unexpected message type."),
        )
        .expect("Could not process message.");
    match alice_processed_message.into_content() {
        ProcessedMessageContent::ExternalJoinProposalMessage(proposal) =&gt; {
            alice_group
                .store_pending_proposal(alice_provider.storage(), *proposal)
                .unwrap();
            let (_commit, welcome, _group_info) = alice_group
                .commit_to_pending_proposals(alice_provider, &amp;alice_signature_keys)
                .expect("Could not commit");
            assert_eq!(alice_group.members().count(), 1);
            alice_group
                .merge_pending_commit(alice_provider)
                .expect("Could not merge commit");
            assert_eq!(alice_group.members().count(), 2);

            let welcome: MlsMessageIn = welcome.expect("Welcome was not returned").into();
            let welcome = welcome
                .into_welcome()
                .expect("expected the message to be a welcome message");

            let bob_group = StagedWelcome::new_from_welcome(
                bob_provider,
                mls_group_create_config.join_config(),
                welcome,
                None,
            )
            .expect("Bob could not stage the the group join")
            .into_group(bob_provider)
            .expect("Bob could not join the group");
            assert_eq!(bob_group.members().count(), 2);
        }
        _ =&gt; unreachable!(),
    }</code></pre>
<p>Outside parties can also make proposals to add other members as long as they are registered as part of the <code>ExternalSendersExtension</code> extension.
Since those proposals are crafted by outsiders, they are always public messages.</p>
<pre><code class="language-rust no_run noplayground">    let proposal = ExternalProposal::new_add::&lt;Provider&gt;(
        bob_key_package.key_package().clone(),
        alice_group.group_id().clone(),
        alice_group.epoch(),
        &amp;ds_signature_keys,
        SenderExtensionIndex::new(0),
    )
    .expect("Could not create external Add proposal");</code></pre>
<p>It is then up to one of the group members to process the proposal and commit it.</p>
<pre><code class="language-rust no_run noplayground">    let alice_processed_message = alice_group
        .process_message(
            alice_provider,
            proposal
                .into_protocol_message()
                .expect("Unexpected message type."),
        )
        .expect("Could not process message.");
    match alice_processed_message.into_content() {
        ProcessedMessageContent::ProposalMessage(proposal) =&gt; {
            alice_group
                .store_pending_proposal(alice_provider.storage(), *proposal)
                .unwrap();
            assert_eq!(alice_group.members().count(), 2);
            alice_group
                .commit_to_pending_proposals(alice_provider, &amp;alice_signature_keys)
                .expect("Could not commit");
            alice_group
                .merge_pending_commit(alice_provider)
                .expect("Could not merge commit");
            assert_eq!(alice_group.members().count(), 1);
        }
        _ =&gt; unreachable!(),
    }</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="removing-members-from-a-group"><a class="header" href="#removing-members-from-a-group">Removing members from a group</a></h1>
<h2 id="immediate-operation-1"><a class="header" href="#immediate-operation-1">Immediate operation</a></h2>
<p>Members can be removed from the group atomically with the <code>.remove_members()</code> function, which takes the <code>KeyPackageRef</code> of group member as input. References to the <code>KeyPackage</code>s of group members can be obtained using the <code>.members()</code> function, from which one can in turn compute the <code>KeyPackageRef</code> using their <code>.hash_ref()</code> function.</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome_option, _group_info) = charlie_group
        .remove_members(
            charlie_provider,
            &amp;charlie_signature_keys,
            &amp;[bob_member.index],
        )
        .expect("Could not remove Bob from group.");</code></pre>
<p>The function returns the tuple <code>(MlsMessageOut, Option&lt;Welcome&gt;)</code>. The <code>MlsMessageOut</code> contains a Commit message that needs to be fanned out to existing group members.
Even though members were removed in this operation, the Commit message could potentially also cover Add Proposals previously received in the epoch. Therefore the function can also optionally return a <code>Welcome</code> message. The <code>Welcome</code> message must be sent to the newly added members.</p>
<h2 id="proposal-1"><a class="header" href="#proposal-1">Proposal</a></h2>
<p>Members can also be removed as a proposal (without the corresponding Commit message) by using the <code>.propose_remove_member()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, _proposal_ref) = alice_group
        .propose_remove_member(
            alice_provider,
            &amp;alice_signature_keys,
            charlie_group.own_leaf_index(),
        )
        .expect("Could not create proposal to remove Charlie.");</code></pre>
<p>In this case, the function returns an <code>MlsMessageOut</code> that needs to be fanned out to existing group members.</p>
<h2 id="getting-removed-from-a-group"><a class="header" href="#getting-removed-from-a-group">Getting removed from a group</a></h2>
<p>A member is removed from a group if another member commits to a remove proposal targeting the member’s leaf. Once the to-be-removed member merges that commit via <code>merge_staged_commit()</code>, all other proposals in that commit will still be applied, but the group will be marked as inactive afterward. The group remains usable, e.g., to examine the membership list after the final commit was processed, but it won’t be possible to create or process new messages.</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessageContent::StagedCommitMessage(staged_commit) =
        bob_processed_message.into_content()
    {
        let remove_proposal = staged_commit
            .remove_proposals()
            .next()
            .expect("An unexpected error occurred.");

        // We construct a RemoveOperation enum to help us interpret the remove operation
        let remove_operation = RemoveOperation::new(remove_proposal, &amp;bob_group)
            .expect("An unexpected Error occurred.");

        match remove_operation {
            RemoveOperation::WeLeft =&gt; unreachable!(),
            // We expect this variant, since Bob was removed by Charlie
            RemoveOperation::WeWereRemovedBy(member) =&gt; {
                assert!(matches!(member, Sender::Member(member) if member == charlies_leaf_index));
            }
            RemoveOperation::TheyLeft(_) =&gt; unreachable!(),
            RemoveOperation::TheyWereRemovedBy(_) =&gt; unreachable!(),
            RemoveOperation::WeRemovedThem(_) =&gt; unreachable!(),
        }

        // Merge staged Commit
        bob_group
            .merge_staged_commit(bob_provider, *staged_commit)
            .expect("Error merging staged commit.");
    } else {
        unreachable!("Expected a StagedCommit.");
    }

    // Check we didn't receive a Welcome message
    assert!(welcome_option.is_none());

    // Check that Bob's group is no longer active
    assert!(!bob_group.is_active());
    let members = bob_group.members().collect::&lt;Vec&lt;Member&gt;&gt;();
    assert_eq!(members.len(), 2);
    let credential0 = members[0].credential.serialized_content();
    let credential1 = members[1].credential.serialized_content();
    assert_eq!(credential0, b"Alice");
    assert_eq!(credential1, b"Charlie");</code></pre>
<h2 id="external-proposal-1"><a class="header" href="#external-proposal-1">External Proposal</a></h2>
<p>Parties outside the group can also make proposals to remove members as long as they are registered as part of the <code>ExternalSendersExtension</code> extension.
Since those proposals are crafted by outsiders, they are always public messages.</p>
<pre><code class="language-rust no_run noplayground">    let proposal = ExternalProposal::new_remove::&lt;Provider&gt;(
        bob_index,
        alice_group.group_id().clone(),
        alice_group.epoch(),
        &amp;ds_signature_keys,
        SenderExtensionIndex::new(0),
    )
    .expect("Could not create external Remove proposal");</code></pre>
<p>It is then up to one of the group members to process the proposal and commit it.</p>
<pre><code class="language-rust no_run noplayground">    let alice_processed_message = alice_group
        .process_message(
            alice_provider,
            proposal
                .into_protocol_message()
                .expect("Unexpected message type."),
        )
        .expect("Could not process message.");
    match alice_processed_message.into_content() {
        ProcessedMessageContent::ProposalMessage(proposal) =&gt; {
            alice_group
                .store_pending_proposal(alice_provider.storage(), *proposal)
                .unwrap();
            assert_eq!(alice_group.members().count(), 2);
            alice_group
                .commit_to_pending_proposals(alice_provider, &amp;alice_signature_keys)
                .expect("Could not commit");
            alice_group
                .merge_pending_commit(alice_provider)
                .expect("Could not merge commit");
            assert_eq!(alice_group.members().count(), 1);
        }
        _ =&gt; unreachable!(),
    }</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="updating-own-leaf-node"><a class="header" href="#updating-own-leaf-node">Updating own leaf node</a></h1>
<h2 id="immediate-operation-2"><a class="header" href="#immediate-operation-2">Immediate operation</a></h2>
<p>Members can update their own leaf node atomically with the <code>.self_update()</code> function.
By default, only the HPKE encryption key is updated. The application can however also provide more parameters like a new credential, capabilities and extensions using the <code>LeafNodeParameters</code> struct.</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome_option, _group_info) = bob_group
        .self_update(
            bob_provider,
            &amp;bob_signature_keys,
            LeafNodeParameters::default(),
        )
        .expect("Could not update own key package.")
        .into_contents();</code></pre>
<p>The function returns a <code>CommitMessageBundle</code>, which consists of the Commit message that needs to be fanned out to existing group members.
Even though the member updates its own leaf node only in this operation, the Commit message could potentially also cover Add Proposals that were previously received in the epoch. Therefore the <code>CommitMessagBundle</code> can also contain a <code>Welcome</code> message. The <code>Welcome</code> message must be sent to the newly added members.</p>
<p>Members can use the <code>.self_update_with_new_signer()</code> function to also update the <code>Signer</code> used to sign future MLS messages.</p>
<pre><code class="language-rust no_run noplayground">
    let new_signer_bundle = NewSignerBundle {
        signer: &amp;alice_new_signature_keys,
        credential_with_key: alice_new_credential,
    };

    let message_bundle = alice_group
        .self_update_with_new_signer(
            alice_provider,
            &amp;alice_old_signature_keys,
            new_signer_bundle,
            LeafNodeParameters::default(),
        )
        .unwrap();

    let (mls_message_out, welcome, group_info) = message_bundle.into_contents();</code></pre>
<p>When constructing the <code>NewSignerBundle</code>, the <code>Signer</code> must match the public key and credential in the <code>CredentialWithKey</code>. When using <code>self_update_with_new_signer</code>, <code>LeafNodeParameters</code> may not contain a <code>CredentialWithKey</code>.</p>
<h2 id="proposal-2"><a class="header" href="#proposal-2">Proposal</a></h2>
<p>Members can also update their leaf node as a proposal (without the corresponding Commit message) by using the <code>.propose_self_update()</code> function. Just like with the <code>.self_update()</code> function, optional parameters can be set through <code>LeafNodeParameters</code>:</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, _proposal_ref) = alice_group
        .propose_self_update(
            alice_provider,
            &amp;alice_signature_keys,
            LeafNodeParameters::default(),
        )
        .expect("Could not create update proposal.");</code></pre>
<p>In this case, the function returns an <code>MlsMessageOut</code> that needs to be fanned out to existing group members.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="using-additional-authenticated-data-aad"><a class="header" href="#using-additional-authenticated-data-aad">Using Additional Authenticated Data (AAD)</a></h1>
<p>The Additional Authenticated Data (AAD) is a byte sequence that can be included in both private and public messages. By design, it is always authenticated (signed) but never encrypted. Its purpose is to contain data that can be inspected but not changed while a message is in transit.</p>
<h2 id="setting-the-aad"><a class="header" href="#setting-the-aad">Setting the AAD</a></h2>
<p>Members can set the AAD by calling the <code>.set_aad()</code> function. The AAD will remain set until the next API call that successfully generates an <code>MlsMessageOut</code>. Until then, the AAD can be inspected with the <code>.aad()</code> function.</p>
<pre><code class="language-rust no_run noplayground">    alice_group.set_aad(b"Additional Authenticated Data".to_vec());

    assert_eq!(alice_group.aad(), b"Additional Authenticated Data");</code></pre>
<h2 id="inspecting-the-aad"><a class="header" href="#inspecting-the-aad">Inspecting the AAD</a></h2>
<p>Members can inspect the AAD of an incoming message once the message has been processed. The AAD can be accessed with the <code>.aad()</code> function of a <code>ProcessedMessage</code>.</p>
<pre><code class="language-rust no_run noplayground">    let processed_message = bob_group
        .process_message(bob_provider, protocol_message)
        .expect("Could not process message.");

    assert_eq!(processed_message.aad(), b"Additional Authenticated Data");</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="leaving-a-group"><a class="header" href="#leaving-a-group">Leaving a group</a></h1>
<p>Members can indicate to other group members that they wish to leave the group using the <code>leave_group()</code> function, which creates a remove proposal targeting the member’s own leaf. The member can’t create a Commit message that covers this proposal, as that would violate the Post-compromise Security guarantees of MLS because the member would know the epoch secrets of the next epoch.</p>
<pre><code class="language-rust no_run noplayground">    let queued_message = bob_group
        .leave_group(bob_provider, &amp;bob_signature_keys)
        .expect("Could not leave group");</code></pre>
<p>After successfully sending the proposal to the DS for fanout, there is still the possibility that the remove proposal is not covered in the following commit. The member leaving the group thus has two options:</p>
<ul>
<li>tear down the local group state and ignore all subsequent messages for that group, or</li>
<li>wait for the commit to come through and process it (see also <a href="#getting-removed-from-a-group">Getting Removed</a>).</li>
</ul>
<p>For details on creating Remove Proposals, see <a href="#removing-members-from-a-group">Removing members from a group</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-proposals"><a class="header" href="#custom-proposals">Custom proposals</a></h1>
<p>OpenMLS allows the creation and use of application-defined proposals. To create such a proposal, the application needs to define a Proposal Type in such a way that its value doesn’t collide with any Proposal Types defined in Section 17.4. of RFC 9420. If the proposal is meant to be used only inside of a particular application, the value of the Proposal Type is recommended to be in the range between <code>0xF000</code> and <code>0xFFFF</code>, as that range is reserved for private use.</p>
<p>Custom proposals can contain arbitrary octet-strings as defined by the application. Any policy decisions based on custom proposals will have to be made by the application, such as the decision to include a given custom proposal in a commit, or whether to accept a commit that includes one or more custom proposals. To decide the latter, applications can inspect the queued proposals in a <code>ProcessedMessageContent::StagedCommitMessage(staged_commit)</code>.</p>
<p>Example on how to use custom proposals:</p>
<pre><code class="language-rust no_run noplayground">    // Define a custom proposal type
    let custom_proposal_type = 0xFFFF;

    // Define capabilities supporting the custom proposal type
    let capabilities = Capabilities::new(
        None,
        None,
        None,
        Some(&amp;[ProposalType::Custom(custom_proposal_type)]),
        None,
    );

    // Generate KeyPackage that signals support for the custom proposal type
    let bob_key_package = KeyPackageBuilder::new()
        .leaf_node_capabilities(capabilities.clone())
        .build(
            ciphersuite,
            bob_provider,
            &amp;bob_signer,
            bob_credential_with_key,
        )
        .unwrap();

    // Create a group that supports the custom proposal type
    let mut alice_group = MlsGroup::builder()
        .with_capabilities(capabilities.clone())
        .ciphersuite(ciphersuite)
        .build(alice_provider, &amp;alice_signer, alice_credential_with_key)
        .unwrap();</code></pre>
<pre><code class="language-rust no_run noplayground">    // Create a custom proposal based on an example payload and the custom
    // proposal type defined above
    let custom_proposal_payload = vec![0, 1, 2, 3];
    let custom_proposal =
        CustomProposal::new(custom_proposal_type, custom_proposal_payload.clone());

    let (custom_proposal_message, _proposal_ref) = alice_group
        .propose_custom_proposal_by_reference(
            alice_provider,
            &amp;alice_signer,
            custom_proposal.clone(),
        )
        .unwrap();

    // Have bob process the custom proposal.
    let processed_message = bob_group
        .process_message(
            bob_provider,
            custom_proposal_message.into_protocol_message().unwrap(),
        )
        .unwrap();

    let ProcessedMessageContent::ProposalMessage(proposal) = processed_message.into_content()
    else {
        panic!("Unexpected message type");
    };

    bob_group
        .store_pending_proposal(bob_provider.storage(), *proposal)
        .unwrap();

    // Commit to the proposal
    let (commit, _, _) = alice_group
        .commit_to_pending_proposals(alice_provider, &amp;alice_signer)
        .unwrap();

    let processed_message = bob_group
        .process_message(bob_provider, commit.into_protocol_message().unwrap())
        .unwrap();

    let staged_commit = match processed_message.into_content() {
        ProcessedMessageContent::StagedCommitMessage(staged_commit) =&gt; staged_commit,
        _ =&gt; panic!("Unexpected message type"),
    };

    // Check that the proposal is present in the staged commit
    assert!(staged_commit.queued_proposals().any(|qp| {
        let Proposal::Custom(custom_proposal) = qp.proposal() else {
            return false;
        };
        custom_proposal.proposal_type() == custom_proposal_type
            &amp;&amp; custom_proposal.payload() == custom_proposal_payload
    }));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-application-messages"><a class="header" href="#creating-application-messages">Creating application messages</a></h1>
<p>Application messages are created from byte slices with the <code>.create_message()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let message_alice = b"Hi, I'm Alice!";
    let mls_message_out = alice_group
        .create_message(alice_provider, &amp;alice_signature_keys, message_alice)
        .expect("Error creating application message.");</code></pre>
<p>Note that the theoretical maximum length of application messages is 2^32 bytes. However, messages should be much shorter in practice unless the Delivery Service can cope with long messages.</p>
<p>The function returns an <code>MlsMessageOut</code> that needs to be sent to the Delivery Service for fanout to other group members. To guarantee the best possible Forward Secrecy, the key material used to encrypt messages is immediately discarded after encryption. This means that the message author cannot decrypt application messages. If access to the message’s content is required after creating the message, a copy of the plaintext message should be kept by the application.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="committing-to-pending-proposals"><a class="header" href="#committing-to-pending-proposals">Committing to pending proposals</a></h1>
<p>During an epoch, members can create proposals that are not immediately committed. These proposals are called “pending proposals”. They will automatically be covered by any operation that creates a Commit message (like <code>.add_members(),</code> <code>.remove_members()</code>, etc.).</p>
<p>Some operations (like creating application messages) are not allowed as long as pending proposals exist for the current epoch. In that case, the application must first commit to the pending proposals by creating a Commit message that covers these proposals. This can be done with the <code>commit_to_pending_proposals()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome_option, _group_info) = alice_group
        .commit_to_pending_proposals(alice_provider, &amp;alice_signature_keys)
        .expect("Could not commit to pending proposals.");</code></pre>
<p>The function returns the tuple <code>(MlsMessageOut, Option&lt;Welcome&gt;)</code>. The <code>MlsMessageOut</code> contains a Commit message that needs to be fanned out to existing group members.
If the Commit message also covers Add Proposals previously received in the epoch, a <code>Welcome</code> message is required to invite the new members. Therefore the function can also optionally return a <code>Welcome</code> message that must be sent to the newly added members.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="processing-incoming-messages"><a class="header" href="#processing-incoming-messages">Processing incoming messages</a></h1>
<p>Processing of incoming messages happens in different phases:</p>
<h2 id="deserializing-messages"><a class="header" href="#deserializing-messages">Deserializing messages</a></h2>
<p>Incoming messages can be deserialized from byte slices into an <code>MlsMessageIn</code>:</p>
<pre><code class="language-rust no_run noplayground">    let mls_message =
        MlsMessageIn::tls_deserialize_exact(bytes).expect("Could not deserialize message.");</code></pre>
<p>If the message is malformed, the function will fail with an error.</p>
<h2 id="processing-messages-in-groups"><a class="header" href="#processing-messages-in-groups">Processing messages in groups</a></h2>
<p>In the next step, the message needs to be processed in the context of the
corresponding group.</p>
<p><code>MlsMessageIn</code> can carry all MLS messages, but only <code>PrivateMessageIn</code> and
<code>PublicMessageIn</code> are processed in the context of a group. In OpenMLS these two
message types are combined into a <code>ProtocolMessage</code> <code>enum</code>. There are 3 ways to
extract the messages from an <code>MlsMessageIn</code>:</p>
<ol>
<li><code>MlsMessageIn.try_into_protocol_message()</code> returns a <code>Result&lt;ProtocolMessage, ProtocolMessageError&gt;</code></li>
<li><code>ProtocolMessage::try_from(m: MlsMessageIn)</code> returns a <code>Result&lt;ProtocolMessage, ProtocolMessageError&gt;</code></li>
<li><code>MlsMessageIn.extract()</code> returns an <code>MlsMessageBodyIn</code> <code>enum</code> that has two
variants for <code>PrivateMessageIn</code> and <code>PublicMessageIn</code></li>
</ol>
<p><code>MlsGroup.process_message()</code> accepts either a <code>ProtocolMessage</code>, a
<code>PrivateMessageIn</code>, or a <code>PublicMessageIn</code> and processes the message.
<code>ProtocolMessage.group_id()</code> exposes the group ID that can help the application
find the right group.</p>
<p>If the message was encrypted (i.e. if it was a <code>PrivateMessageIn</code>), it will be
decrypted automatically. The processing performs all syntactic and semantic
validation checks and verifies the message’s signature. The function finally
returns a <code>ProcessedMessage</code> object if all checks are successful.</p>
<pre><code class="language-rust no_run noplayground">    let protocol_message: ProtocolMessage = mls_message
        .try_into_protocol_message()
        .expect("Expected a PublicMessage or a PrivateMessage");
    let processed_message = bob_group
        .process_message(bob_provider, protocol_message)
        .expect("Could not process message.");</code></pre>
<h2 id="interpreting-the-processed-message"><a class="header" href="#interpreting-the-processed-message">Interpreting the processed message</a></h2>
<p>In the last step, the message is ready for inspection. The <code>ProcessedMessage</code>
obtained in the previous step exposes header fields such as group ID, epoch,
sender, and authenticated data. It also exposes the message’s content. There are
3 different content types:</p>
<h3 id="application-messages"><a class="header" href="#application-messages">Application messages</a></h3>
<p>Application messages simply return the original byte slice:</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessageContent::ApplicationMessage(application_message) =
        processed_message.into_content()
    {
        // Check the message
        assert_eq!(application_message.into_bytes(), b"Hi, I'm Alice!");
    }</code></pre>
<h3 id="proposals"><a class="header" href="#proposals">Proposals</a></h3>
<p>Standalone proposals are returned as a <code>QueuedProposal</code>, indicating that they are pending proposals. The proposal can be inspected through the <code>.proposal()</code> function. After inspection, applications should store the pending proposal in the proposal store of the group:</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessageContent::ProposalMessage(staged_proposal) =
        charlie_processed_message.into_content()
    {
        // In the case we received an Add Proposal
        if let Proposal::Add(add_proposal) = staged_proposal.proposal() {
            // Check that Bob was added
            assert_eq!(
                add_proposal.key_package().leaf_node().credential(),
                &amp;bob_credential.credential
            );
        } else {
            panic!("Expected an AddProposal.");
        }

        // Check that Alice added Bob
        assert!(matches!(
            staged_proposal.sender(),
            Sender::Member(member) if *member == alice_group.own_leaf_index()
        ));
        // Store proposal
        charlie_group
            .store_pending_proposal(charlie_provider.storage(), *staged_proposal)
            .unwrap();
    }</code></pre>
<h4 id="rolling-back-proposals"><a class="header" href="#rolling-back-proposals">Rolling back proposals</a></h4>
<p>Operations that add a proposal to the proposal store, will return its reference. This reference can be used to remove
a proposal from the proposal store. This can be useful for example to roll back in case of errors.</p>
<pre><code class="language-rust no_run noplayground">    let (_mls_message_out, proposal_ref) = alice_group
        .propose_add_member(
            alice_provider,
            &amp;alice_signature_keys,
            bob_key_package.key_package(),
        )
        .expect("Could not create proposal to add Bob");
    alice_group
        .remove_pending_proposal(alice_provider.storage(), &amp;proposal_ref)
        .expect("The proposal was not found");</code></pre>
<h3 id="commit-messages"><a class="header" href="#commit-messages">Commit messages</a></h3>
<p>Commit messages are returned as <code>StagedCommit</code> objects. The proposals they cover can be inspected through different functions, depending on the proposal type. After the application has inspected the <code>StagedCommit</code> and approved all the proposals it covers, the <code>StagedCommit</code> can be merged in the current group state by calling the <code>.merge_staged_commit()</code> function. For more details, see the <code>StagedCommit</code> documentation.</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessageContent::StagedCommitMessage(staged_commit) =
        alice_processed_message.into_content()
    {
        // We expect a remove proposal
        let remove = staged_commit
            .remove_proposals()
            .next()
            .expect("Expected a proposal.");
        // Check that Bob was removed
        assert_eq!(
            remove.remove_proposal().removed(),
            bob_group.own_leaf_index()
        );
        // Check that Charlie removed Bob
        assert!(matches!(
            remove.sender(),
            Sender::Member(member) if *member == charlies_leaf_index
        ));
        // Merge staged commit
        alice_group
            .merge_staged_commit(alice_provider, *staged_commit)
            .expect("Error merging staged commit.");
    }</code></pre>
<h3 id="interpreting-remove-operations"><a class="header" href="#interpreting-remove-operations">Interpreting remove operations</a></h3>
<p>Remove operations can have different meanings, such as:</p>
<ul>
<li>We left the group (by our own wish)</li>
<li>We were removed from the group (by another member or a pre-configured sender)</li>
<li>We removed another member from the group</li>
<li>Another member left the group (by their own wish)</li>
<li>Another member was removed from the group (by a member or a pre-configured sender, but not by us)</li>
</ul>
<p>Since all remove operations only appear as a <code>QueuedRemoveProposal</code>, the <code>RemoveOperation</code> enum can be constructed from the remove proposal and the current group state to reflect the scenarios listed above.</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessageContent::StagedCommitMessage(staged_commit) =
        bob_processed_message.into_content()
    {
        let remove_proposal = staged_commit
            .remove_proposals()
            .next()
            .expect("An unexpected error occurred.");

        // We construct a RemoveOperation enum to help us interpret the remove operation
        let remove_operation = RemoveOperation::new(remove_proposal, &amp;bob_group)
            .expect("An unexpected Error occurred.");

        match remove_operation {
            RemoveOperation::WeLeft =&gt; unreachable!(),
            // We expect this variant, since Bob was removed by Charlie
            RemoveOperation::WeWereRemovedBy(member) =&gt; {
                assert!(matches!(member, Sender::Member(member) if member == charlies_leaf_index));
            }
            RemoveOperation::TheyLeft(_) =&gt; unreachable!(),
            RemoveOperation::TheyWereRemovedBy(_) =&gt; unreachable!(),
            RemoveOperation::WeRemovedThem(_) =&gt; unreachable!(),
        }

        // Merge staged Commit
        bob_group
            .merge_staged_commit(bob_provider, *staged_commit)
            .expect("Error merging staged commit.");
    } else {
        unreachable!("Expected a StagedCommit.");
    }</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="persistence-of-group-data"><a class="header" href="#persistence-of-group-data">Persistence of Group Data</a></h1>
<p>The state of a given <code>MlsGroup</code> instance is continuously written to the configured
<code>StorageProvider</code>. Later, the <code>MlsGroup</code> can be loaded from the provider using
the <code>load</code> constructor, which can be called with the respective storage provider
as well as the <code>GroupId</code> of the group to be loaded. For this to work, the group
must have been written to the provider previously.</p>
<h2 id="forward-secrecy-considerations"><a class="header" href="#forward-secrecy-considerations">Forward-Secrecy Considerations</a></h2>
<p>OpenMLS uses the <code>StorageProvider</code> to store sensitive key material. To achieve forward-secrecy (i.e. to prevent an adversary from decrypting messages sent in the past if a client is compromised), OpenMLS frequently deletes previously used key material through calls to the <code>StorageProvider</code>. <code>StorageProvider</code> implementations must thus take care to ensure that values deleted through any of the <code>delete_</code> functions of the trait are irrevocably deleted and that no copies are kept.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="discarding-commits"><a class="header" href="#discarding-commits">Discarding commits</a></h1>
<p>The delivery service may reject a commit sent by a client. In this case, the application needs to ensure that the local state remains the same as it was before the commit was staged.</p>
<h2 id="cleaning-up-local-state-after-discarded-commits"><a class="header" href="#cleaning-up-local-state-after-discarded-commits">Cleaning up local state after discarded commits</a></h2>
<p>Generally, if a commit is discarded (e.g. due to being rejected by the Delivery Service), it can be cleaned up by the application in the following way:</p>
<pre><code class="language-rust no_run noplayground">    // clear pending commit and reset state
    alice_group
        .clear_pending_commit(alice_provider.storage())
        .unwrap();</code></pre>
<p>In general, the application only needs to complete the cleanup above in order to fully restore the local state to the way it was before the commit was staged.</p>
<p>In several other cases, additional cleanup may need to be done.</p>
<h3 id="externaljoin"><a class="header" href="#externaljoin">ExternalJoin</a></h3>
<p>If a staged commit containing an external join proposal must be discarded, the entire <code>MlsGroup</code> instance should be discarded by the application.</p>
<pre><code class="language-rust no_run noplayground">    // delete the `MlsGroup`
    bob_group
        .delete(bob_provider.storage())
        .expect("Could not delete the group");</code></pre>
<h3 id="presharedkey"><a class="header" href="#presharedkey">PreSharedKey</a></h3>
<p>In addition to clearing the staged commit, the application may also clear the pre-shared key from storage.</p>
<pre><code class="language-rust no_run noplayground">    // clear the psk that was stored earlier, if necessary
    alice_provider
        .storage()
        .delete_psk(&amp;psk)
        .expect("Could not delete stored psk");

    // clear pending commit and reset state
    alice_group
        .clear_pending_commit(alice_provider.storage())
        .expect("Could not clear pending commit");</code></pre>
<h3 id="self-update"><a class="header" href="#self-update">Self Update</a></h3>
<p>The storage provider may also be used by the application to store signature keypairs. For self updates that update a signature keypair for the client, if the application has stored a new keypair in the storage provider at this point, it can be deleted from the storage provider here.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="credential-validation"><a class="header" href="#credential-validation">Credential validation</a></h1>
<p>Credential validation is a process that allows a member to verify the validity
of the credentials of other members in the group. The process is described in
detail in the <a href="https://datatracker.ietf.org/doc/html/rfc9420#name-credential-validation">MLS protocol specification</a>.</p>
<p>In practice, the application should check the validity of the credentials of
other members in two instances:</p>
<ul>
<li>When joining a new group (by looking at the ratchet tree)</li>
<li>When <a href="#processing-incoming-messages">processing messages</a> (by looking at a add &amp; update proposals of a StagedCommit)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="working-with-appdata"><a class="header" href="#working-with-appdata">Working with AppData</a></h1>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>Currently this functionality is behind the <code>extensions-draft-08</code> feature.</p>
</blockquote>
<p>So far, applications could store group state that all members should agree on in custom
extensions.
The <a href="https://datatracker.ietf.org/doc/draft-ietf-mls-extensions/08/">MLS Extensions</a> draft specifies a new mechanism to encode application data in the
group state via the <code>AppDataDictionary</code> extension.
When using custom extensions for this purpose, every update message contains the full new state,
for example in a <code>GroupContextExtensionProposal</code>.
The <code>AppDataUpdate</code> proposal allows sending only a diff, which the application interprets to produce
the new state in the <code>AppDataDictionary</code>.</p>
<p>This is very flexible and allows implementing a wide range of diff-style approaches.
However, it puts more burden on the application, since it needs to validate and process the updates itself to produce the new state.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>The extensions draft specifies ComponentIDs to be 32 bit, but after publishing this was reduced
to 16 bit. We are using 16 bit ComponentIDs. More context in issue <a href="https://github.com/mlswg/mls-extensions/issues/69">mls-extensions#69</a></p>
</blockquote>
<p>To demonstrate the API, we need a custom component that we keep in the group.</p>
<h2 id="setting-up-a-custom-component"><a class="header" href="#setting-up-a-custom-component">Setting up a custom Component</a></h2>
<p>Each application component needs:</p>
<ul>
<li>A unique <code>ComponentId</code> (we’ll use <code>0xf042</code>, which is in the private range <code>0x8000..0xffff</code>)</li>
<li>A data format for the stored state</li>
<li>A data format for updates (the “diff”)</li>
<li>Application logic to process updates and compute new state</li>
</ul>
<p>For this example, we’ll build a simple counter where:</p>
<ul>
<li>The stored state is the counter value as a big-endian <code>u32</code></li>
<li>Updates are a single byte: <code>0x01</code> = increment, <code>0x02</code> = decrement</li>
<li>Incrementing a counter that hasn’t been set yet initializes it to 1</li>
<li>Decrementing below zero is invalid and will cause the commit to be rejected</li>
</ul>
<pre><code class="language-rust no_run noplayground">/// Our counter component ID (in the private range 0x8000..0xffff)
const COUNTER_COMPONENT_ID: u16 = 0xf042;

/// The operations that can be performed on the counter
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum CounterOperation {
    Increment = 0x01,
    Decrement = 0x02,
}

impl CounterOperation {
    fn from_byte(byte: u8) -&gt; Option&lt;Self&gt; {
        match byte {
            0x01 =&gt; Some(CounterOperation::Increment),
            0x02 =&gt; Some(CounterOperation::Decrement),
            _ =&gt; None,
        }
    }

    fn to_bytes(self) -&gt; Vec&lt;u8&gt; {
        vec![self as u8]
    }
}

/// Error type for counter operations
#[derive(Debug, Clone, PartialEq, Eq)]
enum CounterError {
    /// Attempted to decrement below zero
    Underflow,
    /// Invalid operation byte
    InvalidOperation,
}

/// Process a list of counter updates, returning the new counter value.
///
/// - `current_value`: The current counter value (None if not yet set)
/// - `updates`: Iterator of update payloads (each is a single byte)
///
/// Returns the new counter value, or an error if the updates are invalid.
fn process_counter_updates&lt;'a&gt;(
    current_value: Option&lt;&amp;[u8]&gt;,
    updates: impl Iterator&lt;Item = &amp;'a [u8]&gt;,
) -&gt; Result&lt;Vec&lt;u8&gt;, CounterError&gt; {
    // Parse current value as big-endian u32, defaulting to 0
    let mut counter: u32 = current_value
        .map(|bytes| {
            let arr: [u8; 4] = bytes.try_into().unwrap_or([0; 4]);
            u32::from_be_bytes(arr)
        })
        .unwrap_or(0);

    // Apply each update
    for update in updates {
        let op_byte = update.first().ok_or(CounterError::InvalidOperation)?;
        let op = CounterOperation::from_byte(*op_byte).ok_or(CounterError::InvalidOperation)?;

        match op {
            CounterOperation::Increment =&gt; {
                counter = counter.saturating_add(1);
            }
            CounterOperation::Decrement =&gt; {
                counter = counter.checked_sub(1).ok_or(CounterError::Underflow)?;
            }
        }
    }

    Ok(counter.to_be_bytes().to_vec())
}</code></pre>
<p>Next, we crate the group.</p>
<h2 id="group-setup"><a class="header" href="#group-setup">Group Setup</a></h2>
<p>Both the group and its members must advertise support for <code>AppDataUpdate</code> proposals and the <code>AppDataDictionary</code> extension. This is done through capabilities and required capabilities.</p>
<pre><code class="language-rust no_run noplayground">/// Set up a group with AppDataUpdate support.
///
/// This creates Alice and Bob with the required capabilities and creates
/// a group where AppDataUpdate proposals are supported.
fn setup_group_with_app_data_support&lt;'a, Provider: OpenMlsProvider&gt;(
    alice_party: &amp;'a CorePartyState&lt;Provider&gt;,
    bob_party: &amp;'a CorePartyState&lt;Provider&gt;,
    ciphersuite: Ciphersuite,
) -&gt; GroupState&lt;'a, Provider&gt; {
    // Define capabilities that include AppDataDictionary extension
    // and AppDataUpdate proposal support
    let capabilities = Capabilities::new(
        None, // protocol versions (default)
        None, // ciphersuites (default)
        Some(&amp;[ExtensionType::AppDataDictionary]),
        Some(&amp;[ProposalType::AppDataUpdate]),
        None, // credentials (default)
    );

    // The group context must require these capabilities so that
    // all members are guaranteed to support them
    let required_capabilities_extension =
        Extension::RequiredCapabilities(RequiredCapabilitiesExtension::new(
            &amp;[ExtensionType::AppDataDictionary], // required extensions
            &amp;[ProposalType::AppDataUpdate],      // required proposals
            &amp;[],                                 // required credentials
        ));

    // Create pre-group states with the capabilities
    let alice_pre_group = alice_party
        .pre_group_builder(ciphersuite)
        .with_leaf_node_capabilities(capabilities.clone())
        .build();

    let bob_pre_group = bob_party
        .pre_group_builder(ciphersuite)
        .with_leaf_node_capabilities(capabilities.clone())
        .build();

    // Configure the group with required capabilities
    let create_config = MlsGroupCreateConfig::builder()
        .ciphersuite(ciphersuite)
        .capabilities(capabilities)
        .use_ratchet_tree_extension(true)
        .with_group_context_extensions(
            Extensions::single(required_capabilities_extension).expect("valid extensions"),
        )
        .build();

    let join_config = create_config.join_config().clone();

    // Alice creates the group
    let mut group_state = GroupState::new_from_party(
        GroupId::from_slice(b"CounterGroup"),
        alice_pre_group,
        create_config,
    )
    .expect("failed to create group");

    // Alice adds Bob
    group_state
        .add_member(AddMemberConfig {
            adder: "alice",
            addees: vec![bob_pre_group],
            join_config,
            tree: None,
        })
        .expect("failed to add Bob");

    group_state
}</code></pre>
<h2 id="sending-and-receiving-proposals"><a class="header" href="#sending-and-receiving-proposals">Sending and receiving proposals</a></h2>
<p>This part doesn’t really change.</p>
<p>Alice sends a proposal to increment the counter:</p>
<pre><code class="language-rust no_run noplayground">./tests/book_code_app_data.rs:send_proposal}}</code></pre>
<p>Bob receives and stores the proposal:</p>
<pre><code class="language-rust no_run noplayground">    // Bob receives and stores the proposal
    let processed_proposal = bob
        .group
        .process_message(
            &amp;bob_party.provider,
            proposal_message
                .into_protocol_message()
                .expect("failed to convert Proposal MlsMessageOut to ProtocolMessage"),
        )
        .expect("failed to process proposal");

    // Verify it's a proposal and store it
    match processed_proposal.into_content() {
        ProcessedMessageContent::ProposalMessage(proposal) =&gt; {
            bob.group
                .store_pending_proposal(bob_party.provider.storage(), *proposal)
                .expect("failed to store proposal");
        }
        _ =&gt; panic!("expected a proposal message"),
    }</code></pre>
<h2 id="sending-commits"><a class="header" href="#sending-commits">Sending Commits</a></h2>
<p>Now, Alice creates a commit that includes:</p>
<ul>
<li>The previously sent proposal (by reference, from her proposal store)</li>
<li>One additional increment proposal (inline)</li>
</ul>
<p>An important change is that Alice must compute the resulting state herself before building the commit:</p>
<pre><code class="language-rust no_run noplayground">    // Alice creates a commit that includes:
    // - The previously sent proposal (by reference, from her proposal store)
    // - Two additional increment proposals (inline)
    let mut commit_stage = alice
        .group
        .commit_builder()
        .add_proposals(vec![
            // Two more increments as inline proposals
            Proposal::AppDataUpdate(Box::new(AppDataUpdateProposal::update(
                COUNTER_COMPONENT_ID,
                CounterOperation::Increment.to_bytes(),
            ))),
        ])
        .load_psks(alice_party.provider.storage())
        .expect("failed to load PSKs");

    // Alice must compute the resulting state before building the commit.
    // She iterates over all AppDataUpdate proposals (both from the proposal
    // store and inline proposals).
    let mut alice_updater = commit_stage.app_data_dictionary_updater();

    process_app_data_proposals(&amp;mut alice_updater, commit_stage.app_data_update_proposals())
        .expect("failed to process proposals");

    // Provide the computed changes to the commit builder
    commit_stage.with_app_data_dictionary_updates(alice_updater.changes());

    // Build and stage the commit
    let commit_bundle = commit_stage
        .build(
            alice_party.provider.rand(),
            alice_party.provider.crypto(),
            &amp;alice.party.signer,
            |_proposal| true, // accept all proposals
        )
        .expect("failed to build commit")
        .stage_commit(&amp;alice_party.provider)
        .expect("failed to stage commit");

    let (commit_message, _welcome, _group_info) = commit_bundle.into_contents();</code></pre>
<h2 id="receiving-commits"><a class="header" href="#receiving-commits">Receiving Commits</a></h2>
<p>Bob receives the commit and must independently compute the same new state. He iterates over the proposals in the commit, resolving references from his proposal store:</p>
<pre><code class="language-rust no_run noplayground">    // Bob receives the commit and must independently compute the same new state.

    // First, unprotect (decrypt) the message
    let commit_in: MlsMessageIn = commit_message.into();
    let unverified_message = bob
        .group
        .unprotect_message(
            &amp;bob_party.provider,
            commit_in
                .into_protocol_message()
                .expect("not a protocol message"),
        )
        .expect("failed to unprotect message");

    // Create an updater for Bob
    let mut bob_updater = bob.group.app_data_dictionary_updater();

    // Get the proposals from the commit
    let committed_proposals = unverified_message
        .committed_proposals()
        .expect("not a commit");

    // Process each proposal, resolving references from the proposal store
    let mut app_data_updates: Vec&lt;AppDataUpdateProposal&gt; = Vec::new();

    for proposal_or_ref in committed_proposals.iter() {
        // Validate and potentially resolve the reference
        let validated = proposal_or_ref
            .clone()
            .validate(
                bob_party.provider.crypto(),
                ciphersuite,
                ProtocolVersion::Mls10,
            )
            .expect("invalid proposal");

        // Resolve to the actual proposal
        let proposal: Box&lt;Proposal&gt; = match validated {
            ProposalOrRef::Proposal(proposal) =&gt; proposal,
            ProposalOrRef::Reference(reference) =&gt; {
                // Look up the proposal in the proposal store
                bob.group
                    .proposal_store()
                    .proposals()
                    .find(|p| p.proposal_reference_ref() == &amp;*reference)
                    .map(|p| Box::new(p.proposal().clone()))
                    .expect("proposal not found in store")
            }
        };

        // Collect AppDataUpdate proposals for processing
        if let Proposal::AppDataUpdate(app_data_proposal) = *proposal {
            app_data_updates.push(*app_data_proposal);
        }
    }

    // Process the collected proposals
    process_app_data_proposals(&amp;mut bob_updater, app_data_updates.iter())
        .expect("failed to process proposals");

    // Now process the message with the computed updates
    let processed_message = bob
        .group
        .process_unverified_message_with_app_data_updates(
            &amp;bob_party.provider,
            unverified_message,
            bob_updater.changes(),
        )
        .expect("failed to process commit");

    // Extract and merge the staged commit
    let staged_commit = match processed_message.into_content() {
        ProcessedMessageContent::StagedCommitMessage(commit) =&gt; commit,
        _ =&gt; panic!("expected a staged commit"),
    };

    bob.group
        .merge_staged_commit(&amp;bob_party.provider, *staged_commit)
        .expect("failed to merge commit");</code></pre>
<p>After both parties merge, they should have identical state:</p>
<pre><code class="language-rust no_run noplayground">    // Both parties should now have identical state
    assert_eq!(
        alice.group.extensions().app_data_dictionary(),
        bob.group.extensions().app_data_dictionary(),
        "dictionaries should match"
    );

    // Verify the counter value is 3 (three increments)
    let alice_dict = alice
        .group
        .extensions()
        .app_data_dictionary()
        .expect("dictionary should exist");

    let counter_bytes = alice_dict
        .dictionary()
        .get(&amp;COUNTER_COMPONENT_ID)
        .expect("counter should exist");

    let counter_value = u32::from_be_bytes(counter_bytes.try_into().expect("invalid length"));
    assert_eq!(counter_value, 2, "counter should be 2 after two increments");</code></pre>
<h2 id="error-handling-invalid-updates"><a class="header" href="#error-handling-invalid-updates">Error Handling: Invalid Updates</a></h2>
<p>If an update would result in invalid state (e.g., decrementing below zero), the application should reject the commit. Here’s what happens when Alice tries to decrement an unset counter:</p>
<pre><code class="language-rust no_run noplayground">    // Alice tries to decrement an unset counter, which should fail.
    let commit_stage = alice
        .group
        .commit_builder()
        .add_proposals(vec![Proposal::AppDataUpdate(Box::new(
            AppDataUpdateProposal::update(
                COUNTER_COMPONENT_ID,
                CounterOperation::Decrement.to_bytes(),
            ),
        ))])
        .load_psks(alice_party.provider.storage())
        .expect("failed to load PSKs");

    let mut alice_updater = commit_stage.app_data_dictionary_updater();

    let proposals: Vec&lt;_&gt; = commit_stage.app_data_update_proposals().collect();

    // This should fail because we can't decrement below zero
    let result = process_app_data_proposals(&amp;mut alice_updater, proposals.into_iter());

    assert_eq!(
        result,
        Err(CounterError::Underflow),
        "decrementing unset counter should fail"
    );

    // Alice should not proceed with the commit since the state is invalid.
    // In a real application, you would handle this error appropriately,
    // perhaps by notifying the user or choosing different proposals.</code></pre>
<p>The application detects the invalid state during proposal processing and can choose not to proceed with the commit (on the sender side) or reject the message (on the receiver side).</p>
<hr>
<h2 id="verifying-consistency"><a class="header" href="#verifying-consistency">Verifying Consistency</a></h2>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="grease-support"><a class="header" href="#grease-support">GREASE Support</a></h1>
<p>GREASE (Generate Random Extensions And Sustain Extensibility) is a mechanism defined in <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-13.5">RFC 9420 Section 13.5</a> to ensure that implementations properly handle unknown values and maintain protocol extensibility.</p>
<h2 id="what-is-grease"><a class="header" href="#what-is-grease">What is GREASE?</a></h2>
<p>GREASE values are special reserved values that follow a specific pattern (<code>0x0A0A, 0x1A1A, 0x2A2A, ..., 0xEAEA</code>) and are used to:</p>
<ol>
<li><strong>Test extensibility</strong>: Ensure implementations don’t reject messages containing unknown values</li>
<li><strong>Prevent ossification</strong>: Help maintain forward compatibility by exercising unknown value handling paths</li>
<li><strong>Identify bugs</strong>: Catch implementations that incorrectly assume all possible values are known</li>
</ol>
<h3 id="rfc-defined-vs-custom-grease-values"><a class="header" href="#rfc-defined-vs-custom-grease-values">RFC-defined vs. Custom GREASE Values</a></h3>
<p>The <a href="#grease-values">15 values defined in RFC 9420</a> are the “official” GREASE values. When OpenMLS generates GREASE values (e.g., via <code>with_grease()</code>), it uses these RFC-defined values. The <code>is_grease()</code> method only returns <code>true</code> for these specific values.</p>
<p>However, <strong>any</strong> unknown value can serve a similar purpose. The difference is that for non-RFC values, we cannot distinguish whether they are intentionally injected “GREASE-like” values or genuinely unknown identifiers from future protocol extensions.</p>
<h3 id="the-purpose-of-grease"><a class="header" href="#the-purpose-of-grease">The Purpose of GREASE</a></h3>
<p><strong>Important:</strong> The entire point of GREASE is that implementations should <strong>not</strong> check for these values. GREASE values exist to ensure that your unknown-value handling code paths are exercised. Applications can inject GREASE values into their capabilities to discourage other implementations from:</p>
<ul>
<li>Failing on unknown values</li>
<li>Hard-coding assumptions about which values exist</li>
<li>Breaking when the protocol is extended</li>
</ul>
<p>See <a href="#important-notes">Important Notes</a> for details on how OpenMLS handles GREASE during validation.</p>
<h2 id="grease-in-openmls"><a class="header" href="#grease-in-openmls">GREASE in OpenMLS</a></h2>
<p>OpenMLS supports GREASE values for the following types:</p>
<ul>
<li><strong>Ciphersuites</strong> (<code>VerifiableCiphersuite</code>)</li>
<li><strong>Extensions</strong> (<code>ExtensionType::Grease</code>)</li>
<li><strong>Proposals</strong> (<code>ProposalType::Grease</code>)</li>
<li><strong>Credentials</strong> (<code>CredentialType::Grease</code>)</li>
</ul>
<h3 id="grease-handling"><a class="header" href="#grease-handling">GREASE Handling</a></h3>
<p>OpenMLS:</p>
<ol>
<li><strong>Recognizes GREASE values</strong> during deserialization</li>
<li><strong>Filters GREASE values</strong> during validation to prevent false negatives (GREASE values are treated the same as unknown values)</li>
<li><strong>Preserves GREASE values</strong> when present in capabilities</li>
<li><strong>Provides convenience methods</strong> to inject random GREASE values into capabilities</li>
</ol>
<p><strong>Note:</strong> GREASE values are NOT automatically injected. Library users who wish to include GREASE values in their capabilities should use the <code>with_grease()</code> method described below.</p>
<h2 id="using-grease-values"><a class="header" href="#using-grease-values">Using GREASE Values</a></h2>
<h3 id="in-capabilities"><a class="header" href="#in-capabilities">In Capabilities</a></h3>
<p>You can include GREASE values in your KeyPackage capabilities to test interoperability:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use openmls::prelude::*;

let capabilities = Capabilities::builder()
    .proposals(vec![
        ProposalType::Add,
        ProposalType::Update,
        ProposalType::Remove,
        ProposalType::Grease(0x0A0A), // Add a GREASE proposal type
    ])
    .extensions(vec![
        ExtensionType::ApplicationId,
        ExtensionType::Grease(0x1A1A), // Add a GREASE extension type
    ])
    .credentials(vec![
        CredentialType::Basic,
        CredentialType::Grease(0x2A2A), // Add a GREASE credential type
    ])
    .build();
<span class="boring">}</span></code></pre>
<h3 id="injecting-random-grease-values"><a class="header" href="#injecting-random-grease-values">Injecting Random GREASE Values</a></h3>
<p>The easiest way to add GREASE values is using the <code>with_grease()</code> method on <code>Capabilities</code> or <code>CapabilitiesBuilder</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use openmls::prelude::*;
use openmls_rust_crypto::OpenMlsRustCrypto;

let provider = OpenMlsRustCrypto::default();

// Using CapabilitiesBuilder
let capabilities = Capabilities::builder()
    .with_grease(provider.rand())
    .build();

// Or on an existing Capabilities instance
let capabilities = Capabilities::default()
    .with_grease(provider.rand());
<span class="boring">}</span></code></pre>
<p>This will add one random GREASE value to each capability list (ciphersuites, extensions, proposals, and credentials) if no GREASE value is already present.</p>
<h3 id="generating-individual-random-grease-values"><a class="header" href="#generating-individual-random-grease-values">Generating Individual Random GREASE Values</a></h3>
<p>OpenMLS also provides a helper function to generate individual random GREASE values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use openmls::grease::random_grease_value;
use openmls_rust_crypto::OpenMlsRustCrypto;

let crypto = OpenMlsRustCrypto::default();
let grease_value = random_grease_value(&amp;crypto);

// Use in capabilities
let grease_proposal = ProposalType::Grease(grease_value);
<span class="boring">}</span></code></pre>
<h3 id="checking-for-grease-values"><a class="header" href="#checking-for-grease-values">Checking for GREASE Values</a></h3>
<p>All GREASE-capable types provide an <code>is_grease()</code> method. Note that this method only identifies the <a href="#grease-values">RFC-defined GREASE values</a>—it cannot detect custom unknown values that serve a similar purpose.</p>
<p><strong>Caution:</strong> As explained in <a href="#the-purpose-of-grease">The Purpose of GREASE</a>, applications should generally <strong>not</strong> use <code>is_grease()</code> for filtering or decision-making. The method exists primarily for OpenMLS’s internal validation logic and for testing/debugging purposes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use openmls::prelude::*;

let proposal = ProposalType::Grease(0x0A0A);
assert!(proposal.is_grease());

let extension = ExtensionType::Grease(0x1A1A);
assert!(extension.is_grease());

let credential = CredentialType::Grease(0x2A2A);
assert!(credential.is_grease());

use openmls_traits::types::VerifiableCiphersuite;
let ciphersuite = VerifiableCiphersuite::new(0x3A3A);
assert!(ciphersuite.is_grease());
<span class="boring">}</span></code></pre>
<h2 id="grease-values"><a class="header" href="#grease-values">GREASE Values</a></h2>
<p>The following 15 values are defined as GREASE values in RFC 9420:</p>
<ul>
<li><code>0x0A0A</code></li>
<li><code>0x1A1A</code></li>
<li><code>0x2A2A</code></li>
<li><code>0x3A3A</code></li>
<li><code>0x4A4A</code></li>
<li><code>0x5A5A</code></li>
<li><code>0x6A6A</code></li>
<li><code>0x7A7A</code></li>
<li><code>0x8A8A</code></li>
<li><code>0x9A9A</code></li>
<li><code>0xAAAA</code></li>
<li><code>0xBABA</code></li>
<li><code>0xCACA</code></li>
<li><code>0xDADA</code></li>
<li><code>0xEAEA</code></li>
</ul>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes</a></h2>
<h3 id="grease-values-cannot-be-used-for-operations"><a class="header" href="#grease-values-cannot-be-used-for-operations">GREASE Values Cannot Be Used for Operations</a></h3>
<p>GREASE ciphersuites, in particular, cannot be used for actual cryptographic operations. They exist only to test capability negotiation and should never be selected as the active ciphersuite for a group.</p>
<h3 id="validation-automatically-filters-grease"><a class="header" href="#validation-automatically-filters-grease">Validation Automatically Filters GREASE</a></h3>
<p>When OpenMLS validates capabilities, it automatically filters out GREASE values. This means:</p>
<ul>
<li>Two members with different GREASE values in their capabilities can still interoperate</li>
<li>GREASE values don’t affect capability intersection or matching</li>
<li>Required capabilities never include GREASE values</li>
</ul>
<h3 id="interoperability-testing"><a class="header" href="#interoperability-testing">Interoperability Testing</a></h3>
<p>Including GREASE values in your capabilities is recommended for testing interoperability with other MLS implementations. It helps ensure that:</p>
<ol>
<li>Other implementations correctly handle unknown values</li>
<li>Your implementation correctly filters GREASE during validation</li>
<li>Protocol extensibility is maintained</li>
</ol>
<h2 id="example-full-usage"><a class="header" href="#example-full-usage">Example: Full Usage</a></h2>
<p>Here’s a complete example showing GREASE usage with the recommended <code>with_grease()</code> method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use openmls::prelude::*;
use openmls_basic_credential::SignatureKeyPair;
use openmls_rust_crypto::OpenMlsRustCrypto;
use openmls_traits::types::Ciphersuite;

let provider = OpenMlsRustCrypto::default();

// Create a credential
let credential = BasicCredential::new(b"Alice".to_vec());
let signature_keys = SignatureKeyPair::new(
    Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519.signature_algorithm()
).unwrap();

// Create capabilities with automatic random GREASE values
let capabilities = Capabilities::builder()
    .with_grease(provider.rand())
    .build();

// Create a KeyPackage with GREASE values
let key_package = KeyPackage::builder()
    .leaf_node_capabilities(capabilities)
    .build(
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519,
        &amp;provider,
        &amp;signature_keys,
        CredentialWithKey {
            credential: credential.into(),
            signature_key: signature_keys.public().into(),
        },
    )
    .unwrap();

// The KeyPackage can be used normally - GREASE values are handled during validation
<span class="boring">}</span></code></pre>
<h3 id="example-manually-specifying-grease-values"><a class="header" href="#example-manually-specifying-grease-values">Example: Manually Specifying GREASE Values</a></h3>
<p>If you need to specify particular GREASE values (e.g., for testing or interoperability):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use openmls::prelude::*;
use openmls_basic_credential::SignatureKeyPair;
use openmls_rust_crypto::OpenMlsRustCrypto;
use openmls_traits::types::Ciphersuite;

let provider = OpenMlsRustCrypto::default();

// Create a credential
let credential = BasicCredential::new(b"Alice".to_vec());
let signature_keys = SignatureKeyPair::new(
    Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519.signature_algorithm()
).unwrap();

// Create capabilities with specific GREASE values
let capabilities = Capabilities::builder()
    .proposals(vec![
        ProposalType::Add,
        ProposalType::Update,
        ProposalType::Remove,
        ProposalType::Grease(0x0A0A),
        ProposalType::Grease(0x1A1A),
    ])
    .extensions(vec![
        ExtensionType::ApplicationId,
        ExtensionType::Grease(0x2A2A),
    ])
    .credentials(vec![
        CredentialType::Basic,
        CredentialType::Grease(0x3A3A),
    ])
    .build();

// Create a KeyPackage with these capabilities
let key_package = KeyPackage::builder()
    .leaf_node_capabilities(capabilities)
    .build(
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519,
        &amp;provider,
        &amp;signature_keys,
        CredentialWithKey {
            credential: credential.into(),
            signature_key: signature_keys.public().into(),
        },
    )
    .unwrap();
<span class="boring">}</span></code></pre>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-13.5">RFC 9420 Section 13.5: GREASE</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc8701.html">RFC 8701: Applying GREASE to TLS Extensibility</a> - The original GREASE specification for TLS</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h1>
<p>OpenMLS can be built for WebAssembly. However, it does require two features that WebAssembly itself does not provide: access to secure randomness and the current time. Currently, this means that it can only run in a runtime that provides common JavaScript APIs (e.g. in the browser or node.js), accessed through the <code>web_sys</code> crate.
You can enable the <code>js</code> feature on the <code>openmls</code> crate to signal that the APIs are available.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fork-resolution"><a class="header" href="#fork-resolution">Fork Resolution</a></h1>
<p>If members of a group merge different commits, the group state is called forked.
At this point, the group members have different keys and will not be able to decrypt
each others’ messages. While this should not happen in normal operation, it may
still occur due to bugs. When enabling the <code>fork-resolution-helpers</code> feature,
OpenMLS comes with helpers to get a working group again. There are two helpers,
and they use different mechanisms.</p>
<p>The <code>readd</code> helper removes and then re-adds members that are forked. This requires
that the caller knows the set of members that are forked. It is relatively
efficient, especially if only a small number of members forked.</p>
<p>The <code>reboot</code> helper creates a new group and helps with migrating the entire group
state over. This includes extensions in the group context, as well as re-inviting
all the members.</p>
<p>We provide examples for how to use both, and in the end provide some guidance on
detecting forks.</p>
<h2 id="readd-example"><a class="header" href="#readd-example"><code>readd</code> Example</a></h2>
<p>First, let’s create a forked group. In this example, Alice creates a group and
adds Bob. Then, they both merge different commits to add Charlie.</p>
<pre><code class="language-rust no_run noplayground">    // Alice creates a group
    let mut alice_group = MlsGroup::new(
        alice_provider,
        &amp;alice_signature_keys,
        &amp;mls_group_create_config,
        alice_credential.clone(),
    )
    .unwrap();

    // Alice adds Bob and merges the commit
    let add_bob_messages = alice_group
        .commit_builder()
        .propose_adds(vec![bob_kpb.key_package().clone()])
        .load_psks(alice_provider.storage())
        .unwrap()
        .build(
            alice_provider.rand(),
            alice_provider.crypto(),
            &amp;alice_signature_keys,
            |_| true,
        )
        .unwrap()
        .stage_commit(alice_provider)
        .unwrap();

    alice_group.merge_pending_commit(alice_provider).unwrap();

    // Bob joins from the welcome
    let welcome = add_bob_messages.into_welcome().unwrap();
    let mut bob_group =
        StagedWelcome::new_from_welcome(bob_provider, mls_group_config, welcome.clone(), None)
            .unwrap()
            .into_group(bob_provider)
            .unwrap();

    // Now Alice and Bob both add Charlie and merge their own commit.
    // This forks the group.
    let charlie_kpb = generate_key_package(
        ciphersuite,
        charlie_credential,
        Extensions::empty(),
        charlie_provider,
        &amp;charlie_signature_keys,
    );

    let add_charlie_messages = alice_group
        .commit_builder()
        .propose_adds(vec![charlie_kpb.key_package().clone()])
        .load_psks(alice_provider.storage())
        .unwrap()
        .build(
            alice_provider.rand(),
            alice_provider.crypto(),
            &amp;alice_signature_keys,
            |_| true,
        )
        .unwrap()
        .stage_commit(alice_provider)
        .unwrap();

    bob_group
        .commit_builder()
        .propose_adds(vec![charlie_kpb.key_package().clone()])
        .load_psks(bob_provider.storage())
        .unwrap()
        .build(
            bob_provider.rand(),
            bob_provider.crypto(),
            &amp;bob_signature_keys,
            |_| true,
        )
        .unwrap()
        .stage_commit(bob_provider)
        .unwrap();

    alice_group.merge_pending_commit(alice_provider).unwrap();
    bob_group.merge_pending_commit(bob_provider).unwrap();

    // Charlie joins using Alice's invite
    let welcome = add_charlie_messages.into_welcome().unwrap();
    let mut charlie_group =
        StagedWelcome::new_from_welcome(charlie_provider, mls_group_config, welcome, None)
            .unwrap()
            .into_group(charlie_provider)
            .unwrap();

    // We should be forked now, double-check
    // Alice and Charlie are on the same state
    assert_eq!(
        alice_group.confirmation_tag(),
        charlie_group.confirmation_tag()
    );
    // But Bob is different from the other two
    assert_ne!(bob_group.confirmation_tag(), alice_group.confirmation_tag());
    assert_ne!(
        bob_group.confirmation_tag(),
        charlie_group.confirmation_tag()
    );
</code></pre>
<p>Then, Alice removes and re-adds Bob using the helper.
We assume here that Alice knows that only Bob merged the wrong commit. This
information needs to be transferred somehow, see <a href="#fork-detection">Fork Detection</a>.
Notice how Alice needs to provide a new key package for Bob.</p>
<pre><code class="language-rust no_run noplayground">    // Let Alice re-add the members of the other partition (i.e. Bob)
    let bob_new_kpb = generate_key_package(
        ciphersuite,
        bob_credential,
        Extensions::empty(),
        bob_provider,
        &amp;bob_signature_keys,
    );

    // Alice and Charlie are in the same partition
    let our_partition = &amp;[alice_group.own_leaf_index(), charlie_group.own_leaf_index()];
    let builder = alice_group.recover_fork_by_readding(our_partition).unwrap();

    // Here we iterate over the members of the complement partition to get their key packages.
    // In this example this is trivial, but the pattern extends to more realistic scenarios.
    let readded_key_packages = builder
        .complement_partition()
        .iter()
        .map(|member| {
            let basic_credential = BasicCredential::try_from(member.credential.clone()).unwrap();
            match basic_credential.identity() {
                b"Bob" =&gt; bob_new_kpb.key_package().clone(),
                other =&gt; panic!(
                    "we only expect bob to be re-added, but found {:?}",
                    String::from_utf8(other.to_vec()).unwrap()
                ),
            }
        })
        .collect();

    // Specify the key packages to be re-added and create the commit
    let readd_messages = builder
        .provide_key_packages(readded_key_packages)
        .load_psks(alice_provider.storage())
        .unwrap()
        .build(
            alice_provider.rand(),
            alice_provider.crypto(),
            &amp;alice_signature_keys,
            |_| true,
        )
        .unwrap()
        .stage_commit(alice_provider)
        .unwrap();

    // Make Bob re-join the group and Alice and Charlie merge the commit that adds Bob.
    let (commit, welcome, _) = readd_messages.into_contents();
    let welcome = welcome.unwrap();
    let bob_group = StagedWelcome::new_from_welcome(bob_provider, mls_group_config, welcome, None)
        .unwrap()
        .into_group(bob_provider)
        .unwrap();

    alice_group.merge_pending_commit(alice_provider).unwrap();

    if let ProcessedMessageContent::StagedCommitMessage(staged_commit) = charlie_group
        .process_message(charlie_provider, commit.into_protocol_message().unwrap())
        .unwrap()
        .into_content()
    {
        charlie_group
            .merge_staged_commit(charlie_provider, *staged_commit)
            .unwrap()
    } else {
        panic!("expected a commit")
    }

    // The fork should be fixed now, double-check
    assert_eq!(alice_group.confirmation_tag(), bob_group.confirmation_tag());
    assert_eq!(
        alice_group.confirmation_tag(),
        charlie_group.confirmation_tag()
    );
    assert_eq!(
        charlie_group.confirmation_tag(),
        bob_group.confirmation_tag()
    );</code></pre>
<p>In the end, they all can communicate again.</p>
<h2 id="reboot-example"><a class="header" href="#reboot-example"><code>reboot</code> Example</a></h2>
<p>Again, let’s create a forked group. In this example, Alice creates a group and
adds Bob. Then, they both merge different commits to add Charlie.</p>
<pre><code class="language-rust no_run noplayground">    // Alice creates a group
    let mut alice_group = MlsGroup::new(
        alice_provider,
        &amp;alice_signature_keys,
        &amp;mls_group_create_config,
        alice_credential.clone(),
    )
    .unwrap();

    // Alice adds Bob and merges the commit
    let add_bob_messages = alice_group
        .commit_builder()
        .propose_adds(vec![bob_kpb.key_package().clone()])
        .load_psks(alice_provider.storage())
        .unwrap()
        .build(
            alice_provider.rand(),
            alice_provider.crypto(),
            &amp;alice_signature_keys,
            |_| true,
        )
        .unwrap()
        .stage_commit(alice_provider)
        .unwrap();

    alice_group.merge_pending_commit(alice_provider).unwrap();

    // Bob joins from the welcome
    let welcome = add_bob_messages.into_welcome().unwrap();
    let mut bob_group =
        StagedWelcome::new_from_welcome(bob_provider, mls_group_config, welcome, None)
            .unwrap()
            .into_group(bob_provider)
            .unwrap();

    // Now Alice and Bob both add Charlie and merge their own commit.
    // This forks the group.
    let charlie_kpb = generate_key_package(
        ciphersuite,
        charlie_credential.clone(),
        Extensions::empty(),
        charlie_provider,
        &amp;charlie_signature_keys,
    );

    let add_charlie_messages = alice_group
        .commit_builder()
        .propose_adds(vec![charlie_kpb.key_package().clone()])
        .load_psks(alice_provider.storage())
        .unwrap()
        .build(
            alice_provider.rand(),
            alice_provider.crypto(),
            &amp;alice_signature_keys,
            |_| true,
        )
        .unwrap()
        .stage_commit(alice_provider)
        .unwrap();

    bob_group
        .commit_builder()
        .propose_adds(vec![charlie_kpb.key_package().clone()])
        .load_psks(bob_provider.storage())
        .unwrap()
        .build(
            bob_provider.rand(),
            bob_provider.crypto(),
            &amp;bob_signature_keys,
            |_| true,
        )
        .unwrap()
        .stage_commit(bob_provider)
        .unwrap();

    alice_group.merge_pending_commit(alice_provider).unwrap();
    bob_group.merge_pending_commit(bob_provider).unwrap();

    // Charlie joins using Alice's invite
    let welcome = add_charlie_messages.into_welcome().unwrap();
    let charlie_group =
        StagedWelcome::new_from_welcome(charlie_provider, mls_group_config, welcome, None)
            .unwrap()
            .into_group(charlie_provider)
            .unwrap();

    // We shoulkd be forked now, double-check
    // Alice and Charlie are on the same state
    assert_eq!(
        alice_group.confirmation_tag(),
        charlie_group.confirmation_tag()
    );
    // But Bob is different from the other two
    assert_ne!(bob_group.confirmation_tag(), alice_group.confirmation_tag());
    assert_ne!(
        bob_group.confirmation_tag(),
        charlie_group.confirmation_tag()
    );</code></pre>
<p>Then, Alice sets up a new group and adds everyone from the old group. In this
approach, she not only needs to provide key packages for all members, but also
set a new group id and migrate the group context extensions, because these might
be contain e.g. the old group id. This is the responsibility of the application,
so the API just exposes the old extensions and expects the new ones.</p>
<pre><code class="language-rust no_run noplayground">    // Let Alice reboot the group. For that she needs new key packages for Bob and Charlie, a;s
    // well as a new group ID.
    let bob_new_kpb = generate_key_package(
        ciphersuite,
        bob_credential,
        Extensions::empty(),
        bob_provider,
        &amp;bob_signature_keys,
    );

    let charlie_new_kpb = generate_key_package(
        ciphersuite,
        charlie_credential,
        Extensions::empty(),
        charlie_provider,
        &amp;charlie_signature_keys,
    );

    let new_group_id: GroupId = GroupId::from_slice(
        alice_group
            .group_id()
            .as_slice()
            .iter()
            .copied()
            .chain(b"-new".iter().copied())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .as_slice(),
    );

    let (mut alice_group, reboot_messages) = alice_group
        .reboot(new_group_id)
        .finish(
            Extensions::empty(),
            vec![
                bob_new_kpb.key_package().clone(),
                charlie_new_kpb.key_package().clone(),
            ],
            // We can use this closure to add more proposals to the commit builder that is used to
            // create the commit that readds all the other members, but in this case we will leave
            // it as-is.
            |builder| builder,
            alice_provider,
            &amp;alice_signature_keys,
            alice_credential,
        )
        .unwrap();

    alice_group.merge_pending_commit(alice_provider).unwrap();

    // Bob and Charlie join the new group
    let welcome = reboot_messages.into_welcome().unwrap();
    let bob_group =
        StagedWelcome::new_from_welcome(bob_provider, mls_group_config, welcome.clone(), None)
            .unwrap()
            .into_group(bob_provider)
            .unwrap();
    assert_eq!(bob_group.own_leaf_index(), LeafNodeIndex::new(1));

    let charlie_group =
        StagedWelcome::new_from_welcome(charlie_provider, mls_group_config, welcome, None)
            .unwrap()
            .into_group(charlie_provider)
            .unwrap();
    assert_eq!(charlie_group.own_leaf_index(), LeafNodeIndex::new(2));

    // The fork should be fixed now, double-check
    assert_eq!(alice_group.confirmation_tag(), bob_group.confirmation_tag());
    assert_eq!(
        alice_group.confirmation_tag(),
        charlie_group.confirmation_tag()
    );
    assert_eq!(
        bob_group.confirmation_tag(),
        charlie_group.confirmation_tag()
    );</code></pre>
<p>In the end, they all can communicate again.</p>
<h2 id="fork-detection"><a class="header" href="#fork-detection">Fork Detection</a></h2>
<p>Before initiating fork resolution, we first need to detect that a fork happened.
In addition, for using the <code>readd</code> mechanism, we also need to know the members
that forked.</p>
<p>One simple technique that may work, depending on how the delivery service works,
is to consider all incoming non-decryptable messages as a sign that there is a fork.
However, this may lead to false positives and is not enough to know the membership.</p>
<p>One way to learn about this that every member send a message when they merges a
commit, encrypted for the old epoch, that contains the hash of the commit they are
merging. This way, all group members know which commits are merged, and the <code>readd</code>
strategy can be used to resolve possible forks.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits--external-types"><a class="header" href="#traits--external-types">Traits &amp; External Types</a></h1>
<p>OpenMLS defines several traits that have to be implemented to use
OpenMLS.
The main goal is to allow OpenMLS to use different implementations for its
cryptographic primitives, persistence, and random number generation.
This should make it possible to plug in anything from <a href="https://www.w3.org/TR/WebCryptoAPI/">WebCrypto</a> to secure
enclaves.</p>
<ul>
<li><a href="#openmls-traits">Traits</a></li>
<li><a href="#external-types">External Types</a></li>
</ul>
<h2 id="using-storage"><a class="header" href="#using-storage">Using storage</a></h2>
<p>The store is probably one of the most interesting traits because applications
that use OpenMLS will interact with it.
See the <a href="#storageprovider">StorageProvider trait</a> description for details.</p>
<p>In the following examples, we have a <code>ciphersuite</code> and a <code>provider</code> (<code>OpenMlsProvider</code>).</p>
<pre><code class="language-rust no_run noplayground">    // First we generate a credential and key package for our user.
    let credential = BasicCredential::new(b"User ID".to_vec());
    let signature_keys = SignatureKeyPair::new(ciphersuite.into()).unwrap();

    // This key package includes the private init and encryption key as well.
    // See [`KeyPackageBundle`].
    let key_package = KeyPackage::builder()
        .build(
            ciphersuite,
            provider,
            &amp;signature_keys,
            CredentialWithKey {
                credential: credential.into(),
                signature_key: signature_keys.to_public_vec().into(),
            },
        )
        .unwrap();</code></pre>
<p>Retrieving a value from the store is as simple as calling <code>read</code>.
The retrieved key package bundles the private keys for the init and encryption keys
as well.</p>
<pre><code class="language-rust no_run noplayground">    // Read the key package
    let read_key_package: Option&lt;KeyPackageBundle&gt; = provider
        .storage()
        .key_package(&amp;hash_ref)
        .expect("Error reading key package");
    assert_eq!(
        read_key_package.unwrap().key_package(),
        key_package.key_package()
    );</code></pre>
<p>The <code>delete</code> is called with the identifier to delete a value.</p>
<pre><code class="language-rust no_run noplayground">    // Delete the key package
    let hash_ref = key_package
        .key_package()
        .hash_ref(provider.crypto())
        .unwrap();
    provider
        .storage()
        .delete_key_package(&amp;hash_ref)
        .expect("Error deleting key package");</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="openmls-traits"><a class="header" href="#openmls-traits">OpenMLS Traits</a></h1>
<blockquote>
<p><strong>⚠️ These traits are responsible for all cryptographic operations and randomness
within OpenMLS.
Please ensure you know what you’re doing when implementing your own versions.</strong></p>
</blockquote>
<p>Because implementing the <code>OpenMLSCryptoProvider</code> is challenging, requires
tremendous care, and is not what the average OpenMLS consumer wants to (or should)
do, we provide two implementations that can be used.</p>
<ul>
<li><a href="https://crates.io/crates/openmls_rust_crypto">Rust Crypto</a></li>
<li><a href="https://crates.io/crates/openmls_libcrux_crypto">Libcrux Crypto</a></li>
</ul>
<p><strong>Rust Crypto Provider</strong>
The go-to default at the moment is an implementation using commonly used, native
Rust crypto implementations.</p>
<p><strong>Libcrux Crypto Provider</strong>
A crypto provider backed by the high-assurance cryptography library [libcrux].
Currently only supports relatively modern x86 and amd64 CPUs, as it requires
AES-NI, SIMD and AVX.</p>
<h2 id="the-traits"><a class="header" href="#the-traits">The Traits</a></h2>
<p>There are 4 different traits defined in the <a href="https://crates.io/crates/openmls_traits">OpenMLS traits crate</a>.</p>
<h3 id="openmlsrand"><a class="header" href="#openmlsrand">OpenMlsRand</a></h3>
<p>This trait defines two functions to generate arrays and vectors, and is used by
OpenMLS to generate randomness for key generation and random identifiers.
While there is the commonly used <a href="https://crates.io/crates/rand">rand crate</a>, not all implementations use it.
OpenMLS, therefore, defines its own randomness trait that needs to be implemented
by an OpenMLS crypto provider.
It simply needs to implement two functions to generate cryptographically secure
randomness and store it in an array or vector.</p>
<pre><code class="language-rust no_run noplayground">pub trait OpenMlsRand {
    type Error: std::error::Error + Debug;

    /// Fill an array with random bytes.
    fn random_array&lt;const N: usize&gt;(&amp;self) -&gt; Result&lt;[u8; N], Self::Error&gt;;

    /// Fill a vector of length `len` with bytes.
    fn random_vec(&amp;self, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
}</code></pre>
<h3 id="openmlscrypto"><a class="header" href="#openmlscrypto">OpenMlsCrypto</a></h3>
<p>This trait defines all cryptographic functions required by OpenMLS. In particular:</p>
<ul>
<li>HKDF</li>
<li>Hashing</li>
<li>AEAD</li>
<li>Signatures</li>
<li>HPKE</li>
</ul>
<h3 id="storageprovider"><a class="header" href="#storageprovider">StorageProvider</a></h3>
<p>This trait defines an API for a storage backend that is used for all OpenMLS
persistence.</p>
<p>The store provides functions for reading and updating stored values.
Each sort of value has separate methods for accessing or mutating the state.
In order to decouple the provider from the OpenMLS implementation, while still
having legible types at the provider, there are traits that mirror all the types
stored by OpenMLS. The provider methods use values constrained by these traits as
as arguments.</p>
<pre><code class="language-rust no_run noplayground">/// Each trait in this module corresponds to a type. Some are used as keys, some as
/// entities, and some both. Therefore, the Key and/or Entity traits also need to be implemented.
pub mod traits {
    use super::{Entity, Key};

    // traits for keys, one per data type
    pub trait GroupId&lt;const VERSION: u16&gt;: Key&lt;VERSION&gt; {}
    pub trait SignaturePublicKey&lt;const VERSION: u16&gt;: Key&lt;VERSION&gt; {}
    pub trait HashReference&lt;const VERSION: u16&gt;: Key&lt;VERSION&gt; {}
    pub trait PskId&lt;const VERSION: u16&gt;: Key&lt;VERSION&gt; {}
    pub trait EncryptionKey&lt;const VERSION: u16&gt;: Key&lt;VERSION&gt; {}
    pub trait EpochKey&lt;const VERSION: u16&gt;: Key&lt;VERSION&gt; {}

    // traits for entity, one per type
    pub trait QueuedProposal&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait TreeSync&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait GroupContext&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait InterimTranscriptHash&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait ConfirmationTag&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait SignatureKeyPair&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait PskBundle&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait HpkeKeyPair&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait GroupState&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait GroupEpochSecrets&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait LeafNodeIndex&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait MessageSecrets&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait ResumptionPskStore&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait KeyPackage&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait MlsGroupJoinConfig&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait LeafNode&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}
    pub trait ApplicationExportTree&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; {}

    // traits for types that implement both
    pub trait ProposalRef&lt;const VERSION: u16&gt;: Entity&lt;VERSION&gt; + Key&lt;VERSION&gt; {}
}</code></pre>
<p>The traits are generic over a <code>VERSION</code>, which is used to ensure that the values
that are persisted can be upgraded when OpenMLS changes the stored structs.</p>
<p>The traits used as arguments to the storage methods are constrained to implement
the <code>Key</code> or <code>Entity</code> traits as well, depending on whether they are only used for
addressing (in which case they are a <code>Key</code>) or whether they represent a stored
value (in which case they are an <code>Entity</code>).</p>
<pre><code class="language-rust no_run noplayground">/// Key is a trait implemented by all types that serve as a key (in the database sense) to in the
/// storage. For example, a GroupId is a key to the stored entities for the group with that id.
/// The point of a key is not to be stored, it's to address something that is stored.
pub trait Key&lt;const VERSION: u16&gt;: Serialize {}</code></pre>
<pre><code class="language-rust no_run noplayground">/// Entity is a trait implemented by the values being stored.
pub trait Entity&lt;const VERSION: u16&gt;: Serialize + DeserializeOwned {}</code></pre>
<p>An implementation of the storage trait should ensure that it can address and
efficiently handle values.</p>
<h4 id="example-key-packages"><a class="header" href="#example-key-packages">Example: Key packages</a></h4>
<p>This is only an example, but it illustrates that the application may need to do more
when it comes to implementing storage.</p>
<p>Key packages are only deleted by OpenMLS when they are used and <em>not</em> last resort
key packages (which may be used multiple times).
The application needs to implement some logic to manage last resort key packages.</p>
<pre><code class="language-rust no_run noplayground">    fn write_key_package&lt;
        HashReference: traits::HashReference&lt;VERSION&gt;,
        KeyPackage: traits::KeyPackage&lt;VERSION&gt;,
    &gt;(
        &amp;self,
        hash_ref: &amp;HashReference,
        key_package: &amp;KeyPackage,
    ) -&gt; Result&lt;(), Self::Error&gt;;</code></pre>
<p>The application may store the hash references in a separate list with a validity
period.</p>
<pre><code class="language-rust ro_run noplayground">fn write_key_package&lt;
    HashReference: traits::HashReference&lt;VERSION&gt;,
    KeyPackage: traits::KeyPackage&lt;VERSION&gt;,
&gt;(
    &amp;self,
    hash_ref: &amp;HashReference,
    key_package: &amp;KeyPackage,
) -&gt; Result&lt;(), Self::Error&gt; {
    // Get the validity from the application in some way.
    let validity = self.get_validity(hash_ref);

    // Store the reference and its validity period.
    self.store_hash_ref(hash_ref, validity);

    // Store the actual key package.
    self.store_key_package(hash_ref, key_package);
}</code></pre>
<p>This allows the application to iterate over the hash references and delete outdated
key packages.</p>
<h3 id="openmlsprovider"><a class="header" href="#openmlsprovider">OpenMlsProvider</a></h3>
<p>Additionally, there’s a wrapper trait defined that is expected to be passed into
the public OpenMLS API.
Some OpenMLS APIs require only one of the sub-traits, though.</p>
<pre><code class="language-rust no_run noplayground">pub trait OpenMlsProvider {
    type CryptoProvider: crypto::OpenMlsCrypto;
    type RandProvider: random::OpenMlsRand;
    type StorageProvider: storage::StorageProvider&lt;{ storage::CURRENT_VERSION }&gt;;

    // Get the storage provider.
    fn storage(&amp;self) -&gt; &amp;Self::StorageProvider;

    /// Get the crypto provider.
    fn crypto(&amp;self) -&gt; &amp;Self::CryptoProvider;

    /// Get the randomness provider.
    fn rand(&amp;self) -&gt; &amp;Self::RandProvider;
}</code></pre>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>It is not necessary to implement all sub-traits if one functionality is missing.
Suppose you want to use a persisting storage provider. In that case, it is
sufficient to do a new implementation of the <code>StorageProvider</code> trait and
combine it with one of the provided crypto and randomness trait implementations.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="external-types"><a class="header" href="#external-types">External Types</a></h1>
<p>For interoperability, this crate also defines several types and algorithm
identifiers.</p>
<p><strong>AEADs</strong></p>
<p>The following AEADs are defined.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize)]
#[repr(u16)]
/// AEAD types
pub enum AeadType {
    /// AES GCM 128
    Aes128Gcm = 0x0001,

    /// AES GCM 256
    Aes256Gcm = 0x0002,
</code></pre>
<p>An AEAD provides the following functions to get the according values for each
algorithm.</p>
<ul>
<li><code>tag_size</code></li>
<li><code>key_size</code></li>
<li><code>nonce_size</code></li>
</ul>
<p><strong>Hashing</strong></p>
<p>The following hash algorithms are defined.</p>
<pre><code class="language-rust no_run noplayground">#[repr(u8)]
#[allow(non_camel_case_types)]
/// Hash types
pub enum HashType {
    Sha2_256 = 0x04,</code></pre>
<p>A hash algorithm provides the following functions to get the according values for each
algorithm.</p>
<ul>
<li><code>size</code></li>
</ul>
<p><strong>Signatures</strong></p>
<p>The following signature schemes are defined.</p>
<pre><code class="language-rust no_run noplayground">    TlsDeserializeBytes,
    TlsSize,
)]
#[repr(u16)]
pub enum SignatureScheme {
    /// ECDSA_SECP256R1_SHA256
    ECDSA_SECP256R1_SHA256 = 0x0403,
    /// ECDSA_SECP384R1_SHA384
    ECDSA_SECP384R1_SHA384 = 0x0503,
    /// ECDSA_SECP521R1_SHA512
    ECDSA_SECP521R1_SHA512 = 0x0603,
    /// ED25519</code></pre>
<h1 id="hpke-types"><a class="header" href="#hpke-types">HPKE Types</a></h1>
<p>The HPKE implementation is part of the crypto provider as well.
The crate, therefore, defines the necessary types too.</p>
<p>The HPKE algorithms are defined as follows.</p>
<pre><code class="language-rust no_run noplayground">
/// KEM Types for HPKE
#[derive(PartialEq, Eq, Copy, Clone, Debug, Serialize, Deserialize)]
#[repr(u16)]
pub enum HpkeKemType {
    /// DH KEM on P256
    DhKemP256 = 0x0010,

    /// DH KEM on P384
    DhKemP384 = 0x0011,

    /// DH KEM on P521
    DhKemP521 = 0x0012,

    /// DH KEM on x25519
    DhKem25519 = 0x0020,</code></pre>
<pre><code class="language-rust no_run noplayground">    /// XWing combiner for ML-KEM and X25519
    XWingKemDraft6 = 0x004D,
}

/// KDF Types for HPKE
#[derive(PartialEq, Eq, Copy, Clone, Debug, Serialize, Deserialize)]
#[repr(u16)]
pub enum HpkeKdfType {
    /// HKDF SHA 256
    HkdfSha256 = 0x0001,</code></pre>
<pre><code class="language-rust no_run noplayground">    /// HKDF SHA 512
    HkdfSha512 = 0x0003,
}

/// AEAD Types for HPKE.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[repr(u16)]
pub enum HpkeAeadType {
    /// AES GCM 128
    AesGcm128 = 0x0001,

    /// AES GCM 256
    AesGcm256 = 0x0002,</code></pre>
<p>In addition, helper structs for <code>HpkeCiphertext</code> and <code>HpkeKeyPair</code> are defined.</p>
<pre><code class="language-rust no_run noplayground">///     opaque kem_output&lt;V&gt;;
///     opaque ciphertext&lt;V&gt;;
/// } HPKECiphertext;
/// ```</code></pre>
<pre><code class="language-rust no_run noplayground">    Eq,
    Clone,
    Serialize,
    Deserialize,</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="message-validation"><a class="header" href="#message-validation">Message Validation</a></h1>
<p>OpenMLS implements a variety of syntactical and semantical checks, both when parsing and processing incoming commits and when creating own commits.</p>
<h2 id="validation-steps"><a class="header" href="#validation-steps">Validation steps</a></h2>
<p>Validation is enforced using Rust’s type system. The chain of functions used to process incoming messages is described in the chapter on <a href="#processing-incoming-messages">Processing incoming messages</a>, where each function takes a distinct type as input and produces a distinct type as output, thus ensuring that the individual steps can’t be skipped. We now detail which step performs which validation checks.</p>
<h3 id="syntax-validation"><a class="header" href="#syntax-validation">Syntax validation</a></h3>
<p>Incoming messages in the shape of a byte string can only be deserialized into a <code>MlsMessageIn</code> struct. Deserialization ensures that the message is a syntactically correct MLS message, i.e., either a PublicMessage or a PrivateMessage.
Further syntax checks are applied for the latter case once the message is decrypted.</p>
<h3 id="semantic-validation"><a class="header" href="#semantic-validation">Semantic validation</a></h3>
<p>Every function in the processing chain performs several semantic validation steps. For a list of these steps, see <a href="#detailed-list-of-validation-steps">below</a>. In the following, we will give a brief overview of which function performs which category of checks.</p>
<h4 id="wire-format-policy-and-basic-message-consistency-validation"><a class="header" href="#wire-format-policy-and-basic-message-consistency-validation">Wire format policy and basic message consistency validation</a></h4>
<p><code>MlsMessageIn</code> struct instances can be passed into the <code>.parse_message()</code> function of the <code>MlsGroup</code> API, which validates that the message conforms to the group’s <a href="#group-configuration">wire format policy</a>. The function also performs several basic semantic validation steps, such as consistency of Group id, Epoch, and Sender data between message and group (<code>ValSem002</code>-<code>ValSem007</code>). It also checks if the sender type (e.g., <code>Member</code>, <code>NewMember</code>, etc.) matches the type of the message (<code>ValSem112</code>), as well as the presence of a path in case of an External Commit (<code>ValSem246</code>).</p>
<p><code>.parse_message()</code> then returns an <code>UnverifiedMessage</code> struct instance, which can in turn be used as input for <code>.process_unverified_message()</code>.</p>
<h4 id="message-specific-semantic-validation"><a class="header" href="#message-specific-semantic-validation">Message-specific semantic validation</a></h4>
<p><code>.process_unverified_message()</code> performs all other semantic validation steps. In particular, it ensures that …</p>
<ul>
<li>the message is correctly authenticated by a signature (<code>ValSem010</code>), membership tag (<code>ValSem008</code>), and confirmation tag (<code>ValSem205</code>),</li>
<li>proposals are valid relative to one another and the current group state, e.g., no redundant adds or removes targeting non-members (<code>ValSem101</code>-<code>ValSem112</code>),</li>
<li>commits are valid relative to the group state and the proposals it covers (<code>ValSem200</code>-<code>ValSem205</code>) and</li>
<li>external commits are valid according to the spec (<code>ValSem240</code>-<code>ValSem245</code>, <code>ValSem247</code> is checked as part of <code>ValSem010</code>).</li>
</ul>
<p>After performing these steps, messages are returned as <code>ProcessedMessage</code>s that the application can either use immediately (application messages) or inspect and decide if they find them valid according to the application’s policy (proposals and commits). Proposals can then be stored in the proposal queue via <code>.store_pending_proposal()</code>, while commits can be merged into the group state via <code>.merge_staged_commit()</code>.</p>
<h2 id="detailed-list-of-validation-steps"><a class="header" href="#detailed-list-of-validation-steps">Detailed list of validation steps</a></h2>
<p>The following is a list of the individual semantic validation steps performed by OpenMLS, including the location of the tests.</p>
<h3 id="semantic-validation-of-message-framing"><a class="header" href="#semantic-validation-of-message-framing">Semantic validation of message framing</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr>
</thead>
<tbody>
<tr><td><code>ValSem002</code></td><td>Group id</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem003</code></td><td>Epoch</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem004</code></td><td>Sender: Member: check the sender points to a non-blank leaf</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem005</code></td><td>Application messages must use ciphertext</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem006</code></td><td>Ciphertext: decryption needs to work</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem007</code></td><td>Membership tag presence</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem008</code></td><td>Membership tag verification</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem009</code></td><td>Confirmation tag presence</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem010</code></td><td>Signature verification</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem011</code></td><td>PrivateMessageContent padding must be all-zero</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing.rs</code></td></tr>
</tbody>
</table>
</div>
<h3 id="semantic-validation-of-proposals-covered-by-a-commit"><a class="header" href="#semantic-validation-of-proposals-covered-by-a-commit">Semantic validation of proposals covered by a Commit</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr>
</thead>
<tbody>
<tr><td><code>ValSem101</code></td><td>Add Proposal: Signature public key in proposals must be unique among proposals &amp; members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem102</code></td><td>Add Proposal: Init key in proposals must be unique among proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem103</code></td><td>Add Proposal: Encryption key in proposals must be unique among proposals &amp; members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem104</code></td><td>Add Proposal: Init key and encryption key must be different</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem105</code></td><td>Add Proposal: Ciphersuite &amp; protocol version must match the group</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem106</code></td><td>Add Proposal: required capabilities</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem107</code></td><td>Remove Proposal: Removed member must be unique among proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem108</code></td><td>Remove Proposal: Removed member must be an existing group member</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem109</code></td><td>Update Proposal: required capabilities</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem110</code></td><td>Update Proposal: Encryption key must be unique among proposals &amp; members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem111</code></td><td>Update Proposal: The sender of a full Commit must not include own update proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem112</code></td><td>Update Proposal: The sender of a standalone update proposal must be of type member</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem113</code></td><td>All Proposals: The proposal type must be supported by all members of the group</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
</tbody>
</table>
</div>
<h3 id="commit-message-validation"><a class="header" href="#commit-message-validation">Commit message validation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr>
</thead>
<tbody>
<tr><td><code>ValSem200</code></td><td>Commit must not cover inline self Remove proposal</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem201</code></td><td>Path must be present, if at least one proposal requires a path</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem202</code></td><td>Path must be the right length</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem203</code></td><td>Path secrets must decrypt correctly</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem204</code></td><td>Public keys from Path must be verified and match the private keys from the direct path</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem205</code></td><td>Confirmation tag must be successfully verified</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem206</code></td><td>Path leaf node encryption key must be unique among proposals &amp; members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem207</code></td><td>Path encryption keys must be unique among proposals &amp; members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem208</code></td><td>Only one GroupContextExtensions proposal in a commit</td><td>✅</td><td></td><td></td></tr>
<tr><td><code>ValSem209</code></td><td>GroupContextExtensions proposals may only contain extensions support by all members</td><td>✅</td><td></td><td></td></tr>
</tbody>
</table>
</div>
<h3 id="external-commit-message-validation"><a class="header" href="#external-commit-message-validation">External Commit message validation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr>
</thead>
<tbody>
<tr><td><code>ValSem240</code></td><td>External Commit must cover at least one inline ExternalInit proposal</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem241</code></td><td>External Commit must cover at most one inline ExternalInit proposal</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem242</code></td><td>External Commit must only cover inline proposal in allowlist (ExternalInit, Remove, PreSharedKey)</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem244</code></td><td>External Commit must not include any proposals by reference</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem245</code></td><td>External Commit must contain a path</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem246</code></td><td>External Commit signature must be verified using the credential in the path KeyPackage</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
</tbody>
</table>
</div>
<h3 id="ratchet-tree-validation"><a class="header" href="#ratchet-tree-validation">Ratchet tree validation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr>
</thead>
<tbody>
<tr><td><code>ValSem300</code></td><td>Exported ratchet trees must not have trailing blank nodes.</td><td>Yes</td><td>Yes</td><td><code>openmls/src/treesync/mod.rs</code></td></tr>
</tbody>
</table>
</div>
<h3 id="psk-validation"><a class="header" href="#psk-validation">PSK Validation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr>
</thead>
<tbody>
<tr><td><code>ValSem400</code></td><td>The application SHOULD specify an upper limit on the number of past epochs for which the resumption_psk may be stored.</td><td>❌</td><td>❌</td><td>https://github.com/openmls/openmls/issues/1122</td></tr>
<tr><td><code>ValSem401</code></td><td>The nonce of a PreSharedKeyID must have length KDF.Nh.</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem402</code></td><td>PSK in proposal must be of type Resumption (with usage Application) or External.</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem403</code></td><td>Proposal list must not contain multiple PreSharedKey proposals that reference the same PreSharedKeyID.</td><td>✅</td><td>❌</td><td>https://github.com/openmls/openmls/issues/1335</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="app-validation"><a class="header" href="#app-validation">App Validation</a></h1>
<blockquote>
<p><strong>NOTE:</strong> This chapter described the validation steps an application, using OpenMLS, has to perform for safe operation of the MLS protocol.</p>
<p><strong>⚠️</strong> This chapter is work in progress (see <a href="https://github.com/openmls/openmls/issues/1504">#1504</a>).</p>
</blockquote>
<h2 id="credential-validation-1"><a class="header" href="#credential-validation-1">Credential Validation</a></h2>
<h3 id="acceptable-presented-identifiers"><a class="header" href="#acceptable-presented-identifiers">Acceptable Presented Identifiers</a></h3>
<blockquote>
<p>The application using MLS is responsible for specifying which identifiers
it finds acceptable for each member in a group. In other words, following
the model that <a href="https://www.rfc-editor.org/rfc/rfc6125.html">RFC6125</a> describes for TLS, the application maintains a list
of “reference identifiers” for the members of a group, and the credentials
provide “presented identifiers”. A member of a group is authenticated by first
validating that the member’s credential legitimately represents some presented
identifiers, and then ensuring that the reference identifiers for the member
are authenticated by those presented identifiers</p>
<p>– <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-5.3.1-1">RFC9420, Section 5.3.1</a></p>
</blockquote>
<h3 id="validity-of-updated-presented-identifiers"><a class="header" href="#validity-of-updated-presented-identifiers">Validity of Updated Presented Identifiers</a></h3>
<blockquote>
<p>In cases where a member’s credential is being replaced, such as the Update and
Commit cases above, the AS MUST also verify that the set of presented identifiers
in the new credential is valid as a successor to the set of presented identifiers
in the old credential, according to the application’s policy.</p>
<p>– <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-5.3.1-5">RFC9420, Section 5.3.1</a></p>
</blockquote>
<h3 id="application-id-is-not-authenticated-by-as"><a class="header" href="#application-id-is-not-authenticated-by-as">Application ID is Not Authenticated by AS</a></h3>
<blockquote>
<p>However, applications MUST NOT rely on the data in an application_id extension
as if it were authenticated by the Authentication Service, and SHOULD gracefully
handle cases where the identifier presented is not unique.</p>
<p>– <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-5.3.3-6">RFC9420, Section 5.3.3</a></p>
</blockquote>
<h2 id="leafnode-validation"><a class="header" href="#leafnode-validation">LeafNode Validation</a></h2>
<h3 id="specifying-the-maximum-total-acceptable-lifetime"><a class="header" href="#specifying-the-maximum-total-acceptable-lifetime">Specifying the Maximum Total Acceptable Lifetime</a></h3>
<blockquote>
<p>Applications MUST define a maximum total lifetime that is acceptable for a
LeafNode, and reject any LeafNode where the total lifetime is longer than this
duration. In order to avoid disagreements about whether a LeafNode has a valid
lifetime, the clients in a group SHOULD maintain time synchronization (e.g.,
using the Network Time Protocol <a href="https://www.rfc-editor.org/rfc/rfc5905.html">RFC5905</a>).</p>
<p>– <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-7.2-10">RFC9420, Section 7.2</a></p>
</blockquote>
<h2 id="privatemessage-validation"><a class="header" href="#privatemessage-validation">PrivateMessage Validation</a></h2>
<h3 id="structure-of-aad-is-application-defined"><a class="header" href="#structure-of-aad-is-application-defined">Structure of AAD is Application-Defined</a></h3>
<blockquote>
<p>It is up to the application to decide what authenticated_data to provide and
how much padding to add to a given message (if any). The overall size of the
AAD and ciphertext MUST fit within the limits established for the group’s AEAD
algorithm in <a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-aead-limits-08">CFRG-AEAD-LIMITS</a>.</p>
<p>– <a href="https://www.rfc-editor.org/rfc/rfc9420.html#section-6.3.1-11">RFC9420, Section 6.3.1</a></p>
</blockquote>
<p>Therefore, the application must also validate whether the AAD adheres to the
prescribed format.</p>
<h2 id="proposal-validation"><a class="header" href="#proposal-validation">Proposal Validation</a></h2>
<p>When processing a commit, the application has to ensure that the application
specific semantic checks for the validity of the committed proposals are performed.</p>
<p>This should be done on the <code>StagedCommit</code>. Also see the <a href="#processing-incoming-messages">Message Processing</a>
chapter</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessageContent::StagedCommitMessage(staged_commit) =
        alice_processed_message.into_content()
    {
        // We expect a remove proposal
        let remove = staged_commit
            .remove_proposals()
            .next()
            .expect("Expected a proposal.");
        // Check that Bob was removed
        assert_eq!(
            remove.remove_proposal().removed(),
            bob_group.own_leaf_index()
        );
        // Check that Charlie removed Bob
        assert!(matches!(
            remove.sender(),
            Sender::Member(member) if *member == charlies_leaf_index
        ));
        // Merge staged commit
        alice_group
            .merge_staged_commit(alice_provider, *staged_commit)
            .expect("Error merging staged commit.");
    }</code></pre>
<h3 id="external-commits"><a class="header" href="#external-commits">External Commits</a></h3>
<p>The RFC requires the following check</p>
<blockquote>
<p>At most one Remove proposal, with which the joiner removes an old version of themselves. If a Remove proposal is present, then the LeafNode in the path field of the external Commit MUST meet the same criteria as would the LeafNode in an Update for the removed leaf (see Section 12.1.2). In particular, the credential in the LeafNode MUST present a set of identifiers that is acceptable to the application for the removed participant.</p>
</blockquote>
<p>Since OpenMLS does not know the relevant policies, the application MUST ensure
that the credentials are checked according to the policy.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<p>How does OpenMLS (and MLS in general) perform in different settings?</p>
<p>Performance measurements are implemented <a href="https://github.com/openmls/openmls/blob/franziskus/benchmarks/benches/group.rs">here</a> and can be run with <code>cargo bench --bench group</code>.
Check which scenarios and group sizes are enabled in the code.</p>
<p><a href="https://docs.google.com/spreadsheets/d/1nZv8lpT28JctDVo4ARBLZCKcIdvo-h8cIyN3_dIedFU">OpenMLS Performance Spreadsheet</a></p>
<h2 id="real-world-scenarios"><a class="header" href="#real-world-scenarios">Real World Scenarios</a></h2>
<h3 id="stable-group"><a class="header" href="#stable-group">Stable group</a></h3>
<p>Many private groups follow this model.</p>
<ul>
<li>Group is created by user P1</li>
<li>P1 invites a set of N other users</li>
<li>The group is used for messaging between the N+1 members</li>
<li>Every X messages, one user in the group sends an update</li>
</ul>
<h3 id="somewhat-stable-group"><a class="header" href="#somewhat-stable-group">Somewhat stable group</a></h3>
<p>This can model a company or team-wide group where regularly but infrequently, users are added, and users leave.</p>
<ul>
<li>Group is created by user P1</li>
<li>P1 invites a set of N other users</li>
<li>The group is used for messaging between the members</li>
<li>Every X messages, one user in the group sends an update</li>
<li>Every Y messages, Q users are added</li>
<li>Every Z messages, R users are removed</li>
</ul>
<h3 id="high-fluctuation-group"><a class="header" href="#high-fluctuation-group">High fluctuation group</a></h3>
<p>This models public groups where users frequently join and leave.
Real-time scenarios such as <a href="https://gather.town">gather.town</a> are examples of high-fluctuation groups.
It is the same scenario as the somewhat stable group but with a very small Y and Z.</p>
<h2 id="extreme-scenarios"><a class="header" href="#extreme-scenarios">Extreme Scenarios</a></h2>
<p>In addition to the three scenarios above extreme and corner cases are interesting.</p>
<h3 id="every-second-leaf-is-blank"><a class="header" href="#every-second-leaf-is-blank">Every second leaf is blank</a></h3>
<p>Only every second leaf in the tree is non-blank.</p>
<h2 id="use-case-scenarios"><a class="header" href="#use-case-scenarios">Use Case Scenarios</a></h2>
<p>A collection of common use cases/flows from everyday scenarios.</p>
<h3 id="long-time-offline-device"><a class="header" href="#long-time-offline-device">Long-time offline device</a></h3>
<p>Suppose a device has been offline for a while. In that case, it has to process a large number of application and protocol messages.</p>
<h2 id="tree-scenarios"><a class="header" href="#tree-scenarios">Tree scenarios</a></h2>
<p>In addition to the scenarios above, it is interesting to look at the same scenario but with different states of the tree.
For example, take the stable group with N members messaging each other.
What is the performance difference between a message sent right after group setup, i.e., each member only joined the group without other messages being sent, and a tree where every member has sent an update before the message?</p>
<h2 id="measurements"><a class="header" href="#measurements">Measurements</a></h2>
<ul>
<li>Group creation
<ul>
<li>create group</li>
<li>create proposals</li>
<li>create welcome</li>
<li>apply commit</li>
</ul>
</li>
<li>Join group
<ul>
<li>create group from welcome</li>
</ul>
</li>
<li>Send application message</li>
<li>Receive application message</li>
<li>Send update
<ul>
<li>create proposal</li>
<li>create commit</li>
<li>apply commit</li>
</ul>
</li>
<li>Receive update
<ul>
<li>apply commit</li>
</ul>
</li>
<li>Add user sender
<ul>
<li>create proposal</li>
<li>create welcome</li>
<li>apply commit</li>
</ul>
</li>
<li>Existing user getting an add
<ul>
<li>apply commit</li>
</ul>
</li>
<li>Remove user sender
<ul>
<li>create proposal</li>
<li>create commit</li>
<li>apply commit</li>
</ul>
</li>
<li>Existing user getting a remove
<ul>
<li>apply commit</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="forward-secrecy"><a class="header" href="#forward-secrecy">Forward Secrecy</a></h1>
<p>OpenMLS drops key material immediately after a given
key is no longer required by the protocol to achieve forward secrecy. For some keys, this is simple, as they
are used only once, and there is no need to store them for later use. However,
for other keys, the time of deletion is a result of a trade-off between
functionality and forward secrecy. For example, it can be desirable to keep the
<code>SecretTree</code> of past epochs for a while to allow decryption of straggling
application messages sent in previous epochs.</p>
<p>In this chapter, we detail how we achieve forward secrecy for the different types of keys used throughout MLS.</p>
<h2 id="ratchet-tree"><a class="header" href="#ratchet-tree">Ratchet Tree</a></h2>
<p>The ratchet tree contains the secret key material of the client’s leaf, as well
(potentially) that of nodes in its direct path. The secrets in the tree are
changed in the same way as the tree itself: via the merge of a previously
prepared diff.</p>
<h3 id="commit-creation"><a class="header" href="#commit-creation">Commit Creation</a></h3>
<p>Upon the creation of a commit, any fresh key material introduced by the
committer is stored in the diff. It exists alongside the key material of the
ratchet tree before the commit until the client merges the diff, upon which the
key material in the original ratchet tree is dropped.</p>
<p>Because the client cannot know if the commit it creates will conflict with another commit created by another client
for the same epoch, it MUST wait for the acknowledgement from the Delivery Service before merging the diff and dropping
the previous ratchet tree.</p>
<h3 id="commit-processing"><a class="header" href="#commit-processing">Commit Processing</a></h3>
<p>Upon receiving a commit from another group member, the client processes the
commit until they have a <code>StagedCommit</code>, which in turn contains a ratchet tree
diff. The diff contains any potential key material they decrypted from the
commit and any potential key material that was introduced to the tree as
part of an update that someone else committed for them. The key material in the original ratchet tree is dropped as soon as the <code>StagedCommit</code> (and thus the diff) is merged into the tree.</p>
<h3 id="sending-application-messages"><a class="header" href="#sending-application-messages">Sending application messages</a></h3>
<p>When an application message is created, the corresponding encryption key is derived from the <code>SecretTree</code> and immediately discarded after encrypting the message to guarantee the best possible Forward Secrecy. This means that the message author cannot decrypt application messages. If access to the message’s content is required after creating the message, a copy of the plaintext message should be kept by the application.</p>
<h3 id="receiving-encrypted-messages"><a class="header" href="#receiving-encrypted-messages">Receiving encrypted messages</a></h3>
<p>When an encrypted message is received, the corresponding decryption key is derived from the <code>SecretTree</code>. By default, the key material is discarded immediately after decryption for the best possible Forward Secrecy. In some cases, the Delivery Service cannot guarantee reliable operation, and applications need to be more tolerant to accommodate this – at the expense of Forward Secrecy.</p>
<p>OpenMLS can address 3 scenarios:</p>
<ul>
<li>
<p>The Delivery Service cannot guarantee that application messages from one epoch are sent before the beginning of the next epoch. To address this, applications can configure their groups to keep the necessary key material around for past epochs by setting the <code>max_past_epochs</code> field in the <code>MlsGroupCreateConfig</code> to the desired number of epochs.</p>
</li>
<li>
<p>The Delivery Service cannot guarantee that application messages will arrive in order within the same epoch. To address this, applications can configure the <code>out_of_order_tolerance</code> parameter of the <code>SenderRatchetConfiguration</code>. The configuration can be set as the <code>sender_ratchet_configuration</code> parameter of the <code>MlsGroupCreateConfig</code>.</p>
</li>
<li>
<p>The Delivery Service cannot guarantee that application messages won’t be dropped within the same epoch. To address this, applications can configure the <code>maximum_forward_distance</code> parameter of the <code>SenderRatchetConfiguration</code>. The configuration can be set as the <code>sender_ratchet_configuration</code> parameter of the <code>MlsGroupCreateConfig</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="release-management"><a class="header" href="#release-management">Release management</a></h1>
<p>The process for releasing a new version of OpenMLS.</p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>The versioning follows the Rust and semantic <a href="https://semver.org">versioning guidelines</a>.</p>
<h2 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h2>
<p>Release notes are published on GitHub with a full changelog and a discussion in
the “Release” section.
In addition, the release notes are prepended to the CHANGELOG file in each crate’s
root folder.
The entries in the CHANGELOG file should follow the <a href="https://keepachangelog.com/en/1.0.0/">keep a changelog guide</a>.</p>
<h2 id="pre-release-strategy"><a class="header" href="#pre-release-strategy">Pre-release strategy</a></h2>
<p>Before releasing a minor or major version of the OpenMLS crate, a pre-release version
must be published to crates.io.
Pre-release versions are defined by appending a hyphen, and a series of dot-separated identifiers, i.e., <code>-rc.x</code> where <code>x</code> gets counted up starting at 1.
Pre-releases must be tagged but don’t require release notes or other documentation.
It is also sufficient to tag only the most high-level crate being published.</p>
<hr>
<h2 id="crates-in-this-repository"><a class="header" href="#crates-in-this-repository">Crates in this Repository</a></h2>
<p>The crates must be published in the order below.</p>
<ul>
<li><a href="https://github.com/openmls/openmls/blob/main/traits/Cargo.toml">Traits</a></li>
<li><a href="https://github.com/openmls/openmls/blob/main/memory_storage/Cargo.toml">Memory storage</a></li>
<li><a href="https://github.com/openmls/openmls/blob/main/openmls_rust_crypto/Cargo.toml">Rust Crypto provider</a></li>
<li><a href="https://github.com/openmls/openmls/blob/main/openmls/Cargo.toml">OpenMLS</a></li>
</ul>
<h2 id="release-note-and-changelog-template"><a class="header" href="#release-note-and-changelog-template">Release note and changelog template</a></h2>
<pre><code class="language-markdown">## 0.0.0 (2022-02-22)

### Added

- the feature ([#000])

### Changed

- the change ([#000])

### Deprecated

- the deprecated feature ([#000])

### Removed

- the removed feature ([#000])

### Fixed

- the fixed bug ([#000])

### Security

- the fixed security bug ([#000])

[#000]: https://github.com/openmls/openmls/pull/000
</code></pre>
<h2 id="release-checklist"><a class="header" href="#release-checklist">Release checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"> If this is a minor or major release, has a pre-release version been published at least a week before the release?
<ul>
<li>If not, first do so and push the release one week.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Describe the release in the CHANGELOG.md file of each crate.</li>
<li><input disabled="" type="checkbox"> Create and publish a git tag for each crate, e.g. <code>openmls/v0.4.0-rc.99</code>.</li>
<li><input disabled="" type="checkbox"> Create and publish release notes on Github.</li>
<li><input disabled="" type="checkbox"> Publish the crates to crates.io</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
