<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tree Rewrite Project - OpenMLS Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="user_manual/index.html"><strong aria-hidden="true">1.</strong> User manual</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user_manual/identity.html"><strong aria-hidden="true">1.1.</strong> Creating identity keys</a></li><li class="chapter-item expanded "><a href="user_manual/create_key_package.html"><strong aria-hidden="true">1.2.</strong> Creating key packges</a></li><li class="chapter-item expanded "><a href="user_manual/group_config.html"><strong aria-hidden="true">1.3.</strong> Group configuration</a></li><li class="chapter-item expanded "><a href="user_manual/create_group.html"><strong aria-hidden="true">1.4.</strong> Creating groups</a></li><li class="chapter-item expanded "><a href="user_manual/join_from_welcome.html"><strong aria-hidden="true">1.5.</strong> Join a group from a Welcome message</a></li><li class="chapter-item expanded "><a href="user_manual/add_members.html"><strong aria-hidden="true">1.6.</strong> Adding members to a group</a></li><li class="chapter-item expanded "><a href="user_manual/remove_members.html"><strong aria-hidden="true">1.7.</strong> Removing members from a group</a></li><li class="chapter-item expanded "><a href="user_manual/updates.html"><strong aria-hidden="true">1.8.</strong> Updating own key package</a></li><li class="chapter-item expanded "><a href="user_manual/leaving.html"><strong aria-hidden="true">1.9.</strong> Leaving a group</a></li><li class="chapter-item expanded "><a href="user_manual/application_messages.html"><strong aria-hidden="true">1.10.</strong> Creating application messages</a></li><li class="chapter-item expanded "><a href="user_manual/commit_to_proposals.html"><strong aria-hidden="true">1.11.</strong> Committing to pending proposals</a></li><li class="chapter-item expanded "><a href="user_manual/processing.html"><strong aria-hidden="true">1.12.</strong> Processing incoming messages</a></li></ol></li><li class="chapter-item expanded "><a href="message_validation.html"><strong aria-hidden="true">2.</strong> Message Validation</a></li><li class="chapter-item expanded "><a href="tree_rewrite.html" class="active"><strong aria-hidden="true">3.</strong> Tree Rewrite Project</a></li><li class="chapter-item expanded "><a href="type_enfored_verification.html"><strong aria-hidden="true">4.</strong> Type-Enforced Verification</a></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">5.</strong> Performance</a></li><li class="chapter-item expanded "><a href="forward_secrecy.html"><strong aria-hidden="true">6.</strong> Forward Secrecy</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OpenMLS Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tree-rewrite-project"><a class="header" href="#tree-rewrite-project">Tree Rewrite Project</a></h1>
<p><img src="https://img.shields.io/badge/status-wip-orange.svg?style=for-the-badge" alt="" /></p>
<h2 id="treesync"><a class="header" href="#treesync">TreeSync</a></h2>
<p>TreeSync is a tree structure that keeps public data in a left-balanced binary
tree structure and relies on a KeyStore to store private data. Not every node
has to contain data. A node not containing data is considered blank. The
TreeSyncNode API determines how TreeSync interacts with the data it stores.</p>
<p><img src="./static/treesync_api.svg" alt="TreeSync Architecture" /></p>
<h4 id="node-indexing"><a class="header" href="#node-indexing">Node Indexing</a></h4>
<p>The current MLS spec explicitly relies on leaf- or node indices specific to the
array-representation of a tree to indicate individual nodes. Thus, to keep it
simple, this draft of a TreeSync API relies on the same indices.</p>
<p>In an actual implementation, we might have to translate from the array-specific
indices to whatever is used by the actual binary tree implementation underneath
<code>TreeSync</code>.</p>
<h3 id="treesyncnode-api"><a class="header" href="#treesyncnode-api">TreeSyncNode API</a></h3>
<p>TreeSync relies on the <code>TreeSyncNode</code> to represent the layer of abstraction
below it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TreeSyncNode {
    /// Return the value of the node relevant for the parent hash and tree hash.
    /// In case of MLS, this would be the node's HPKEPublicKey. TreeSync
    /// can then gather everything necessary to build the `ParentHashInput`,
    /// `LeafNodeHashInput` and `ParentNodeTreeHashInput` structs for a given node.
    fn node_content(&amp;self) -&gt; &amp;[u8] {}

    /// Get the list of unmerged leaves.
    fn unmerged_leaves(&amp;self) -&gt; &amp;[LeafIndex] {}

    /// Clear the list of unmerged leaves.
    fn clear_unmerged_leaves(&amp;mut self) {}

    /// Add a `LeafIndex` to the node's list of unmerged leaves.
    fn add_unmerged_leaf(&amp;mut self, LeafIndex) {}

    /// Set the parent hash value of this node.
    fn set_parent_hash(&amp;mut self, Vec&lt;u8&gt;) {}

    /// Get the parent hash value of this node.
    fn parent_hash(&amp;self) -&gt; &amp;[u8] {}

    /// Set the tree hash value for the given node.
    /// This assuming that the node caches the tree hash.
    fn set_tree_hash(&amp;mut self, Vec&lt;u8&gt;) {}

    /// Get the tree hash value for the given node.
    fn tree_hash(&amp;self) -&gt; &amp;[u8] {}

    /// Verify the signature on a given leaf node. Returns an
    /// error if called on a non-leaf node.
    fn verify(&amp;self) -&gt; Result&lt;bool, TreeSyncNodeError&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="treesync-api"><a class="header" href="#treesync-api">TreeSync API</a></h3>
<p>Note, that a majority of the tree operations are performed on TreeSyncDiffs (see
below).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TreeSync&lt;Node: TreeSyncNode, KeyStore: TreeSyncKeyStore&gt; {
    FLBBinaryTree&lt;Option&lt;Node&gt;&gt;
}

impl&lt;Node: TreeSyncNode, KeyStore: TreeSyncKeyStore&gt; TreeSync&lt;Node, KeyStore&gt; {
    /// Return the tree hash of the root node.
    fn tree_hash(&amp;self) -&gt; Vec&lt;u8&gt; {}

    /// Verify the parent hash of every parent node in the tree.
    fn verify_parent_hashes -&gt; Result&lt;(), TreeSyncError&gt; {}

    /// Merge the given diff into the `TreeSync` instance. This operation
    /// re-computes all necessary tree hashes.
    /// Note, that the private values corresponding to the ones in the
    /// TreeSync should be committed at the same time.
    fn merge_diff(&amp;mut self, tree_sync_diff: TreeSyncDiff) -&gt; Result&lt;(), TreeSyncError&gt; {}

    /// Create an empty diff based on this TreeSync instance all operations
    /// are created based on an initial, empty diff.
    fn empty_diff(&amp;self) -&gt; TreeSyncDiff {}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="treesyncdiffs"><a class="header" href="#treesyncdiffs">TreeSyncDiffs</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct&lt;Node: TreeSyncNode&gt; TreeSyncDiff&lt;Node&gt; {
    nodes: HashMap&lt;NodeIndex,Option&lt;Node&gt;&gt;,
}

impl&lt;Node: TreeSyncNode, KeyStore: TreeSyncKeyStore&gt; TreeSyncDiff&lt;Node&gt; {
    /// Update a leaf node and blank the nodes in the updated leaf's direct path.
    fn update_leaf(&amp;mut self, leaf_node: Node, leaf_index: LeafIndex) -&gt; TreeSyncDiff {}

    /// Adds a new leaf to the tree either by filling a blank leaf or by creating a new leaf,
    /// inserting intermediate blanks as necessary. This also adds the leaf_index of the new
    /// leaf to the `unmerged_leaves` state of the parent nodes in its direct path.
    fn add_leaf(&amp;mut self, leaf_node: Node) -&gt; Result&lt;TreeSyncDiff, TreeSyncError&gt; {}

    /// Remove a group member by blanking the target leaf and its direct path.
    fn remove_leaf(&amp;mut self, leaf_index: LeafIndex) -&gt; Result&lt;TreeSyncDiff, TreeSyncError&gt; {}

    /// Process a given update path, consisting of a vector of `Node`. This
    /// function
    /// * replaces the nodes in the direct path of the given `leaf_node` with the
    ///   the ones in `path` and
    /// * computes the `parent_hash` of all nodes in the path and compares it to the one in
    ///   the `leaf_node`.
    fn update_path(&amp;mut self, leaf_node: Node, path: Vec&lt;Node&gt;) -&gt; TreeSyncDiff {}

    /// Compute the tree hash of the TreeSync instance we would get when merging the diff.
    fn tree_hash(&amp;self) -&gt; Vec&lt;u8&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="treesync-usage-example"><a class="header" href="#treesync-usage-example">TreeSync Usage Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function demonstrates how TreeSync could be used to manage a tree and could be
/// used in create_commit to create a provisional tree and the
/// corresponding values (tree_hash, commit_secret, etc).
/// It returns the diff resulting from the operations applied to the TreeSync instance,
/// as well as the vector of `NodeSeed`s that can then be encrypted using TreeKEM.
/// Note, that the application with apply_commit is slightly asymmetrical, as we would potentially have
/// to pass in an additional `path` for TreeSync to apply.
fn apply_proposals(&amp;self, key_store: &amp;KeyStore, proposal_list: Vec&lt;Proposal&gt;) -&gt; Result&lt;(TreeSyncDiff), ApplyProposalsError&gt;{
    // ...
    // as Proposals are not generic, we have to translate them
    // individually to TreeSync operations
    // the assumption here is that the list of proposals is already
    // ordered by type and order as per commit
    let mut path_required = false;
    let mut my_new_key_package = None;
    let mut diff = self.tree_sync.empty_diff();
    for proposal in &amp;proposal_list {
        match proposal {
          Update(key_package) =&gt; {
              // If we process an update, we need to include a path in the end
              path_required = true;
              // We process self updates later using the update_path function
              if key_package.identity() != &amp;self.identity {
                  diff.update_leaf(key_package.into())
              } else {
                  my_new_key_package = Some(key_package)
              }
          },
          Add(key_package) =&gt; diff.add(TreeSyncNode::from(key_package)),
          // It's not clear yet how to expose &quot;identity&quot; to TreeSync.
          Remove(leaf_index) =&gt; {
              // If we process a remove, we need to include a path in the end
              path_required = true;
              diff.remove(leaf_index),
          }
        };
    }


    // If we want to create a path and/or one of the updates was a
    // self-update.
    if path_required || my_new_key_package.is_some() {
        // a path is required, but there's no explicit update, generate a new key_package
        if my_new_key_package.is_none() {
            my_new_key_package = key_store.generate_key_package_bundle(...);
        }
        // We assume that this function gives us the path based on the leaf_secret of the
        // key package bundle, which is in the key store.
        let (path, path_secrets) = create_path(&amp;key_store, &amp;my_new_key_package)?;
        // The private values generated in the process are put into the key store
        // This will compute the path secret and set it in the new leaf node.
        diff.update_path(TreeSyncLeafNode(my_new_key_package.unwrap()), path)?;
    } else {
        diff
    }

    // We can now call TreeKEM and encrypt the `path_secrets` (see below).
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="treekem-trait"><a class="header" href="#treekem-trait">TreeKEM Trait</a></h2>
<p>TreeKEM would take one of the &quot;node seed&quot; discussed above and encrypt/decrypt
it. For encryption/decryption it would need access to a TreeSync instance, where
<code>Node</code> implements <code>TreeKemNode</code>, which in turn provides the functions that
TreeKEM needs. In particular, it would have to provide access to the public keys
of each node.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TreeKemNode&lt;KeyStore: TreeSyncKeyStore&gt; {
    /// Encrypt a given plaintext to the node's public key.
    fn encrypt(&amp;self, plaintext: &amp;[u8]) -&gt; HpkeCiphertext {}

    /// Decrypt a given ciphertext using the secret key corresponding to the node.
    fn decrypt(&amp;self, key_store: &amp;KeyStore, ciphertext: &amp;HpkeCiphertext) -&gt; Vec&lt;u8&gt; {}
}

trait&lt;KeyStore: TreeSyncKeyStore&gt; TreeKem&lt;KeyStore&gt; {
    /// Create an UpdatePath by encrypting a vector of `NodeSeed`s
    /// to the direct path of our own leaf.
    fn encrypt_path(&amp;self, path: Vec&lt;NodeSeed&gt;) -&gt; Result&lt;UpdatePath, TreeKemError&gt; {}

    /// Decrypt an UpdatePath, returning the `NodeSeed` and the vector of `Node`s.
    fn decrypt_path(&amp;self, key_store: KeyStore, update_path: UpdatePath) -&gt; Result&lt;(NodeSeed, Vec&lt;Node&gt;), TreeKemError&gt; {}
}

<span class="boring">}
</span></code></pre></pre>
<p>Questions:</p>
<ul>
<li>Should we allow TreeKEM to know about KeyPackages or do we draw the
abstraction line at public keys? It needs to know about KeyPackages to be able
to return an UpdatePath. Otherwise it would be a vector of UpdatePathNode.</li>
</ul>
<p>TODO: Create a KeyStore API for TreeKem. See https://github.com/franziskuskiefer/key-store-rs/blob/main/src/traits.rs</p>
<h3 id="keystore-api-old-api-for-treesync"><a class="header" href="#keystore-api-old-api-for-treesync">KeyStore API (old API for TreeSync)</a></h3>
<p>TreeSync requires a place in which to store secrets and private keys. In
particular, it should store:</p>
<ul>
<li>Pairs of <code>(PrivateState, NodeSeed)</code> indexed by <code>PrivateStateHandle</code> for updates to one's own leaf node. These
are independent of a given group and get consumed when used.</li>
<li>A <code>NodeSeed</code>, which represents the <code>CommitSecret</code> in MLS-terms.</li>
<li>A number of <code>PrivateState</code>, representing the private values of the nodes in
one's own direct path, indexed by Node indices. This includes the
<code>PrivateState</code> of the leaf.</li>
<li>A temporary <code>Vec&lt;PrivateState&gt;</code>, for the private part of a provisional
TreeSync state.</li>
<li>A temporary <code>NodeSeed</code>, for the private part of a provisional TreeSync state.</li>
</ul>
<p>The individual get and erase functions allow the persistence of derivations of
the <code>NodeSeed</code> before deleting it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TreeSyncKeyStore&lt;Node: TreeSyncNode&gt; {
    /// Store a pair of `Node::NodeSeed` and `Node::PrivateState` corresponding to a
    /// `Node` meant to be used as a leaf node in a future update. Note, that
    /// the `Node::NodeSeed` will only be used if we commit the update ourselves.
    fn store_leaf_node_private_state(&amp;mut self, node_seed: Node::NodeSeed, private_values: Node::PrivateState) {}

    /// Take a pair of `Node::NodeSeed` and `Node::PrivateState` corresponding to a
    /// `Node::PrivatStateHandle`, thereby removing it from the store.
    fn take_leaf_node_private_state(&amp;mut self, handle: Node::PrivateStateHandle) -&gt; Result&lt;(Node::NodeSeed, Node:: PrivateState), KeyStoreError&gt; {}

    /// Store the temporary `Vec&lt;Node::PrivateState&gt;` and `Node::NodeSeed`.
    fn store_temporary_private_states(&amp;mut self, private_values: (Vec&lt;Node::PrivateState&gt;, Node::NodeSeed)) {}

    /// Commit to the current temporary `Vec&lt;Node::PrivateState&gt;` and `Node::NodeSeed`
    /// by using it to overwrite the corresponding non-temporary values.
    fn commit_to_temporary_values(&amp;mut self) {}

    /// Get the `Node::NodeSeed`. Note, that it should be removed using
    /// `erase_node_seed` after it was used.
    fn node_seed(&amp;self) -&gt; Node::NodeSeed {}

    /// Get the `Node::NodeSeed`. Note, that it should be removed using
    /// `erase_node_seed` after it was used.
    fn erase_node_seed(&amp;mut self) {}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="binary-tree-api"><a class="header" href="#binary-tree-api">Binary Tree API</a></h2>
<p><code>TreeSync</code>, <code>TreeKEM</code> and <code>TreeDEM</code> rely on an underlying full, left-balenced
binary tree representation <code>FLBBinaryTree</code> to organise its data and to process
it.</p>
<p>As discussed above, the following binary tree API relies on the indices of an
array-based binary tree representation. While the binary tree implementation
needs to provide an interface based on these indices, it does not necessarily
need to organise the data in memory in the style of the array-representation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FLBBinaryTree&lt;Node&gt; {
    /// Obtain a reference to the data contained in the `Node` at index `node_index`.
    /// Returns an error if the index is outside of the tree.
    fn node(&amp;self, node_index: NodeIndex) -&gt; Result&lt;&amp;Node, FLBBBinaryTreeError&gt; {}

    /// Obtain a mutable reference to the data contained in the `Node` at index `node_index`.
    /// Returns an error if the index is outside of the tree.
    fn node_mut(&amp;mut self, node_index: NodeIndex) -&gt; Result&lt;&amp;mut Node, FLBBBinaryTreeError&gt; {}

    /// Add two nodes to the right side of the tree. Nodes can only be
    /// added in pairs to keep the tree full.
    fn add(&amp;mut self, node_1:Node , node_2: Node) -&gt; Result&lt;(), FLBBBinaryTreeError&gt; {}

    /// Remove the two rightmost nodes of the tree.
    fn remove(&amp;mut self) -&gt; Result&lt;(), FLBBBinaryTreeError&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="open-questionstodos"><a class="header" href="#open-questionstodos">Open Questions/TODOs:</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
What's the <code>BinaryTree</code> API? (FK)
<ul>
<li>Added a secion on full, left-balanced BinaryTree API. It leaves a lot of
functionality in <code>TreeSync</code>, but it keeps the interface simple and small.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
How do diffs work with the key store? (FK)
<ul>
<li>There's now a TreeSync specific KeyStore API that includes temporary values.</li>
</ul>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Write an example of what kind of secrets we want to store and when, as
well as what kind of secrets we want to delete and when.</li>
<li><input disabled="" type="checkbox"/>
Store secrets based on group + epoch.</li>
<li><input disabled="" type="checkbox"/>
Implement CRUD interface.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
What's the most efficient data structure for <code>TreeSyncDiff</code>? (FK)
<ul>
<li>If it's a vector, the elements should get a struct.</li>
<li>Initial idea is to make it a <code>HashMap&lt;NodeIndex,TreeSyncNode&gt;</code></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Does any of these structs need internal mutability? (FK)</li>
<li><input disabled="" type="checkbox"/>
Should there be shared functionality for diffs? (FK)</li>
<li><input disabled="" type="checkbox"/>
<code>TreeSync</code> should have a cache for hashes. (FK)
<ul>
<li>The current design requires the underlying nodes to do the hashing.
Not sure if that's the optimal approach.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Design API for TreeDEM</li>
<li><input disabled="" type="checkbox"/>
Rework Diff types to be abstract and independent of the binary tree implementation
<ul>
<li>We have the same argument here as for MLS. We need some way to address individual nodes
and we use indices from the array-based representation for that. As long as the underlying
binary tree maps that to the underlying memory model, it should work fine.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Do we want persistence for diffs?</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="message_validation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="type_enfored_verification.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="message_validation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="type_enfored_verification.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
